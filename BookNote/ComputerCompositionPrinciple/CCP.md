# 计算机组成原理

---

## 计算机系统概述

### 冯诺依曼体系结构

> 冯诺依曼提出了“存储程序”的概念，其思想奠定了现代计算机的基本结构

- 采用“存储程序”的工作方式
- 计算机硬件系统由运算器、存储器、控制器、输入输出设备这五大部件组成
- **指令和数据以同等地位存储在存储器中，形式上没有区别，但计算机能够区分**
- **指令和数据均采用二进制代码表示**。**指令由操作码和地址码组成，操作码指出操作的类型，地址码指出操作数的地址**
- **以运算器为中心** -> 现代计算机以存储器为中心

> “存储程序”的基本思想是：**将事先编好的程序和原始数据送入主存后才能执行，一旦程序被启动执行，就无须操作人员的干预，计算机会自动逐条执行指令，直至程序执行结束**

### 各个硬件的工作原理

#### 主存储器

> CPU能够**直接访问**的存储器是主存储器。**主存储器的工作方式是按存储单元的地址进行存取，这种存储方式称为按地址存取方式**

- 主存储器的最基本组成如下所示：
	- 存储体，存储体存放二进制信息
	- 数据存储寄存器(Memory Data Register)，MAR存放访存地址，经过地址译码后找到所选的存储单元
	- 地址存储寄存器(Memory Address Register)，MDR用于暂存要从存储器中读或写的信息
	- 时序逻辑控制器，用于产生存储器操作所需的各种时序信号

![[主存储器.png]]

##### 存储体

> 存储体由许多存储单元组成，每个存储单元包含若干存储元件，每个存储元件存储一位二进制代码0/1. 因此存储单元可以存储一串二进制代码，这串代码称为存储字，称这串代码的位数为存储字长

- 存储体
	- 存储单元：每个存储单元存放一串二进制代码
	- 存储字(word)：存储单元中二进制代码的组合
	- 存储字长：存储单元中二进制代码的位数
	- 存储元：即存储二进制的电子元件，每个存储元可存储1bit
- **每一个地址都对应一个存储单元**

| 地址 | 存储体 |
| :---: | :---: |
| 0 | 存储单元 |
| 1 | 存储单元 |
| 2 | ... |
| 3 | ... |
| 4 | ... |
| ... | ... |

##### MAR

> MAR用于寻址，**其位数对应着存储单元的个数**，如MAR为10位，则有$2^{10} = 1024$个存储单元。**MAR的长度和PC寄存器的长度相同**

##### MDR

> MDR的位数是存储单元的字长，假如MDR位16位，也就是说一个字的长度位16bit，每个存储单元可存放16bit的数据

> [!warning] 注意，**在现代CPU中，MAR和MDR是存在于CPU中的**

#### 运算器

> 运算器是计算机的执行部件，用于算术运算和逻辑运算。

- 运算器的基本组成如下：
	- 算术逻辑单元(ALU)
	- 寄存器，**前三个寄存器是必须的**
		- 累加寄存器(ACC)
		- 乘商寄存器(MQ)
		- 通用寄存器(X)
		- 变址寄存器(IX)
		- 基址寄存器(BR)
		- ....

- 寄存器作用表

| | 加 | 减 | 乘 | 除 |
| :---: | :---: | :---: | :---: | :---: |
| ACC | 被加数、和 | 被减数、差 | 乘积高位 | 被除数、余数 |
| MQ | | | 乘数、乘积低位 | 商 |
| X | 加数 | 减数 | 被乘数 | 除数 |

![[运算器.png]]

#### 控制器

> 控制器是计算机的指挥中心，使得各部件自动协调地进行工作。控制器由程序计数器(PC)、指令寄存器(IR)和控制单元(CU)组成

- 控制器的基本组成如下所示：
	- PC寄存器，用于**存放当前欲执行指令的地址(也就是下一条指令)**，当执行完毕后自动移动到下一条指令地址的开头。它与主存MAR之间由一条直接通路
	- IR寄存器，用来**存放当前的指令**，其内容来自主存的MDR。指令中的操作码OP(IR)送至CU，用以分析指令并发出各种微操作命令序列，而地址码Ad(IR)送往MAR，用以取操作数
	- CU控制单元，分析指令，给出控制信号

### 计算机的工作过程

![[计算机简单结构.png]]

#### 探究简单C语言代码执行逻辑

``` c
int main() {
	int a = 2, b = 3, c = 1, y = 0;
	y = a * b + c;
	return 0;
}
```

- 编译后装入主存后的结构示意图

| 主存地址 | 操作码 | 地址码 | 注释 |
| :---: | :---: | :---: | :---: |
| 0 | 000001 | 0000000101 | 取数a至ACC | 
| 1 | 000100 | 0000000110 | 乘b得ab，存于ACC中 | 
| 2 | 000011 | 0000000111 | 加c得$ab + c$，存于ACC中 | 
| 3 | 000010 | 0000001000 | 将$ab + c$存于主存单元 | 
| 4 | 000110 | 0000000000 | 停机 | 
| 5 | 000000 | 0000000101 | 原始数据$a=2$ | 
| 6 | 000000 | 0000000101 | 原始数据$b=3$ | 
| 7 | 000000 | 0000000101 | 原始数据$c=1$ | 
| 8 | 000000 | 0000000101 | 原始数据$y=0$ | 

##### 控制器的简单执行逻辑

1. $(PC) = 0x0$，PC寄存器指向第一条指令的存储地址
2. $MAR = (PC)$，MAR得到PC指向的主存地址
3. $(PC) = 0x1$，当PC寄存器执行完后，自动的访问下一条指令的地址
4. $M(MAR) = MDR$， MDR得到MAR指向的主存地址中的数据
5. $IR = (MDR)$，IR得到MDR中对应的指令，开始分析操作码OP(IR)和地址码AD(IR)
6. $CU = OP(IR)$，IR将分析得出的操作码送往CU，让CU分析对应的操作
7. $MAR = AD(IR)$，IR将分析得出的地址码送往MAR，找到需要执行的内存单元
8. 进行对应操作，重复2~8流程，直至程序结束

##### 指令执行过程

1. 取指令
	1. PC -> MAR -> M -> MDR -> IR
	2. 将PC取指令到IR，将PC中的内容送往MAR，MAR中的内容送往存储体中索取对应数据，主存通过地址线上的之地和读信号，从指定存储单元读出指令送到数据线上，MDR从数据线上接受指令信息，传送到IR中
2. 分析指令
	1. OP(IR) -> CU
	2. 指令译码并送出控制信号，控制器CU根据IR中指令的操作码，生成相应的控制信号，送到不同的执行部件
3. 执行指令
	1. AD(IR) -> MAR -> M -> MDR -> ACC
	2. 取数操作。将IR中指令的地址码送给MAR，MAR中的内容送入地址线，同时控制器将读信号送读/写信号线，从主存中取出操作数，并通过数据线送至MDR，再传送至ACC中
4. **每次读完指令，PC就会立即指向下一条指令的地址，$(PC) = (PC) + 1$

##### 代码的简单执行逻辑

1. $(PC) = 0x0$，PC寄存器指向第一条指令的存储地址
2. $MAR = (PC)$，使得$(MAR) = 0$，找到了主存地址为0的位置
3. $(PC) = (PC) + 1$，执行完后，PC指向下一条指令
4. $MDR = M(MAR)$，使得$(MDR) = 000001 0000000101$
5. $IR = (MDR)$，IR寄存器得到指令，开始分析，$OP(IR) = 0000001$，$AD(IR) = 0000000101$
6. $CU = OP(IR)$，将操作码送往CU，CU分析指令，得出是“取数”指令
7. $MAR = AD(IR)$，将地址码送往MAR，使得$(MAR) = 0x5$
8. $MDR = M(MAR)$，将对应地址码中的数据取出，存放在MDR中，使得$(MDR) = 0x2$
9. $ACC = (MDR)$，将MDR的数据送往ACC累加寄存器中，$(ACC) = 0x2$

- 上述步骤其实就是代码中的$int \ a = 2$语句，但是因为$y = a*b + c$的缘故，CPU决定将其送往ACC中，与后续的$b$做乘法后和$c$进行相加操作，因此才会存放在ACC中。

### 计算机系统的多级层次结构

> 计算机是一个软硬件组合的综合体。由于面对应用范围越来越广，必须有复杂的系统软件和硬件的支持。
> 计算机系统的多级层次结构的作用，**就是根据从各种角度所看到的机器之间的有机联系，来分清彼此之间的界面，明确各自的功能，以便构成合理、高效的计算机系统**

> [!warning] 计算机系统层次结构的分层方式，没有统一的标准

- 层次表

| 层次结构 | 用法 | 示例 |
| :---: | :---: | :---: | 
| 虚拟机器 $M4$(高级语言机器) | 用**编译程序翻译**成**汇编语言程序** | $y = a * b + c$ |
| 虚拟机器 $M3$(汇编语言机器) | 用**汇编程序翻译**成**机器语言程序** | LOAD $5$ |
| 虚拟机器 $M2$(操作系统机器) | 向上提供“广义指令”(系统调用) |  |
| 传统机器$M1$(用机器语言的机器) | 用微程序解释机器指令，执行二进制机器指令 | $0000010000000101$ |
| 微程序机器$M0$(微指令系统) | 由硬件直接执行微指令 | PC、IR等 |

- 第一级是微程序机器层，这是一个实在的硬件层
- 第二级是传统机器语言层，也是一个实际的机器层
- 第三级是操作系统层，其由操作系统程序实现，而**操作系统程序是由机器指令和广义指令组成的**，这些广义指令是为了扩展机器功能而设置的，由操作系统定义和解释的软件指令，所以这一层也称为混合层
- 第四层是汇编语言层，其为用户提供一种符号化的语言
- 第五层是高级语言层，其是面向用户的，是为了方便用户编写应用程序而设置的。
- **没有配备软件的纯硬件系统被称为裸机**，**第三层~第五层称为虚拟机**，也就是软件实现的机器，虚拟机器只对该层的观察者存在。
- **层次之间的关系紧密，下层是上层的基础，上层是下层的扩展**

#### 编译

> 将高级语言写的源程序全部语句一次性全部翻译为机器语言程序 -> 一次编译，处处运行
> 代表语言类似：C/C++

- 类似于C/C++的编译，需要经过四个步骤
	- 预处理
	- 编译
	- 汇编
	- 链接

#### 解释

> 将源程序的一条语句翻译为对应机器语言的语句，并立即执行，直至将程序翻译执行完毕 -> 一次翻译，一次运行
> 代表语言类似：Python、JavaScript

- 类似于Python的解释，只需要经过两个步骤
	- 解释
	- 执行

### 计算机的性能指标

#### 存储器的性能指标

> 存储器的性能指标就是主存容量，通俗的讲就是内存大小。**主存容量是指主存储器所能存储信息的最大容量，通常用字节来衡量**

- 主存容量的大小与**MAR和MDR**有关

$$ 
\begin{aligned} 
   &Memory = MAR * MDR \\ 
   eg. MAR = 2^{32}, &\ \ \ MDR = 8bit \rightarrow Memory = 2^{32} * 8bit = 4GB
\end{aligned} 
$$

#### CPU的性能指标

> CPU的性能指标通常和CPU的时钟周期、主频等有关。

##### CPU时钟周期

> 通常为节拍脉冲或T周期，即主频的倒数，它是CPU中最小的时间单位，**执行指令的每个动作至少需要一个时钟周期**

$$ CPU时钟周期 = \frac{1}{CPU主频}Hz $$

##### CPU主频

> CPU主频也被叫做CPU时钟频率。机器内部主时钟的频率，**是衡量机器速度的重要参数**。**对于同一个型号的计算机，其主频越高，完成指令的一个执行步骤所用的时间越短，执行指令的速度越快**

$$ CPU主频 = \frac{1}{CPU时钟周期}Hz $$

##### CPI(Clock cycle Per Instruction)

> CPI，即执行一条指令所需的时钟周期数。不同指令的时钟周期数可能不同，甚至同指令完成的时钟周期数也不同，**因此，一般来说，CPI指该程序或该机器指令集中所有的指令执行所需的平均时钟周期数，此时CPI是一个平均值**

$$ per\_cmd\_cost = CPI \times CPU时钟周期 $$

- Eg：某CPU主频为1000Hz，某程序包括100条指令，平均来看指令的$CPI = 3$。该程序在该CPU上执行需要多久？

$$ 答：time = 100 * CPI * \frac{1}{1000} = 0.3s $$

##### CPU执行时间

> 指运行一个程序所花费的时间

$$ CPU\_cost\_time = \frac{CPU时钟周期数}{主频} = \frac{指令条数 \times CPI}{主频} $$
- 上述表明，CPU的性能(执行时间)取决于三个要素：主频、CPI和指令条数
- 其中，主频、CPI和指令条数是相互制约的，更改指令集可以减少程序所含的指令条数，但可能引起CPU结构的调整，从而增加时钟周期的宽度(降低主频)。

##### IPS

> IPS - Instruction Per Second，即每秒执行的指令数

$$ IPS = \frac{主频}{CPI} $$
- 其中，对于每秒执行的指令数，不止有IPS，还有KIPS、MIPS

##### FLOPS

> FLOPS - Floating-point Operations Per Second，每秒执行多少次浮点运算，还有KFLOPS、MFLOPS、GFLOPS、TFLOPS

- 注意：IPS和FLOPS一样，K、M、G、T为数量单位，而非计算机的二进制，而是十进制

#### 系统整体的性能指标

> 系统整体性能指标，通常使用带宽和字长等来表示的

##### 字长

> 字长是指计算机进行一次整数运算(即定点整数运算)所能处理的二进制数据的位数，通常与CPU的寄存器位数、加法器有关。**因此，字长一般等于内部寄存器的大小，字长越长，数据的比爱是范围越大**

- 字：用来表示被处理信息的单位，用来度量数据类型的宽度
- 字长：指CPU内部用于整数运算的数据通路的宽度，反应了计算机处理信息的能力
- 机器字长：也就是字长
- 指令字长：一个指令字中包含的二进制代码位数，取决于操作码的长度
- 存储字长：一个存储单元存储的二进制代码长度

##### 数据通路带宽

> 数据通路带宽是指**数据总线一个所能并行传送信息的位数**，而此处所说的带宽是指外部数据总线的宽度，和CPU内部的数据总线宽度(内部寄存器)可能不同
> **各个子系统通过数据总线连接形成的数据传送路径称为数据通路**

##### 吞吐量

> **指系统在单位时间内处理请求的数量。其取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存中取出或存入，以及所得结果能多快地从内存中送给外部设备**。这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存储周期

##### 响应时间

> 指从用户像计算机发送一个请求，到系统对该请求做出相应并获得所需要结果的等待时间。

- 通常包括CPU时间(运行一个程序所花费的时间)与等待时间(用于磁盘访问、存储器访问、I/O操作、操作系统开销等)

##### 基准程序

> 专门用来进行性能评价的一组程序，能够很好地反映机器在运行实际负载时的性能，可以通过在不同机器上运行相同的基准程序来比较在不同机器上的运行时间，从而评测其性能

- 对于不同的场合，应该选取不同的基准程序
- 基准程序的性能存在缺陷。

### 习题

#### 题一

``` txt
冯诺依曼机的基本工作方式是()
A. 控制流驱动方式    B. 多指令多数据流方式
C. 微程序控制方式    D. 数据流驱动方式

答：A选项，控制流驱动方式。
```

## 数据的表示和运算

### 进位计数制

> 在计算机内部，所有信息都是二进制编码的
> 1. 二进制只有两种状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位，制造成本低。
> 2. 二进制位的1和0正好与逻辑值“真”和“假”对应，为计算机实现逻辑运算和程序中逻辑判断提供了便利条件
> 3. 二进制编码和运算规则简单，通过逻辑门电路能方便地实现算术运算

#### 十进制计数法

$$
\begin{aligned}
	K_nK_{n-1}...K_2K_1&K_0K_{-1}K_{-2}...K_{-m} \\
	= K_n \times 10^n + K_{n - 1} \times 10^{n-1} + ... + K_2 \times 10^{2} + &K_1 \times 10^1 + K_0 \times 10^0 + K_{-1} \times 10^{-1} + ... + K_{-m} \times 10^{-m}
\end{aligned}
$$

- 其中，10是基数，而$10^i$是第i位的权重

#### 推广->r进制计数法

$$
\begin{aligned}
	K_nK_{n-1}...K_2K_1&K_0K_{-1}K_{-2}...K_{-m} \\
	= K_n \times r^n + K_{n - 1} \times r^{n-1} + ... + K_2 \times r^{2} + &K_1 \times r^1 + K_0 \times r^0 + K_{-1} \times r^{-1} + ... + K_{-m} \times r^{-m}
\end{aligned}
$$

- 基数：每个数码位所用到的不同符号的个数，r进制的基数为r

#### 任意进制转十进制

> 对于任意进制转十进制来说，只需要将该进制每位上的数乘以其权重相加之和即可得到对应十进制

- 二进制转十进制

$$
\begin{aligned}
	(1001.11)_2 &= 1 \times 2^3 + 0 + 0 + 1 \times 2^0 + 1 \times 2^{-1} + 1 \times 2^{-2} \\
				&= 8 + 0 + 0 + 1 + 0.5 + 0.25 \\
				&= 9.75D
\end{aligned}
$$

- 八进制转十进制

$$
\begin{aligned}
	(251.5)_8 &= 2 \times 8^2 + 5 \times 8^1 + 1 \times 8^0 + 5 \times 8^{-1} \\
			  &= 128 + 40 + 1 + 0.625 \\
			  &= 169.625D
\end{aligned}
$$

- 十六进制转十进制

$$
\begin{aligned}
	(AE86.1)_{16} &= A \times 16^3 + E \times 16 ^ 2 + 8 \times 16^1 + 6 \times 16 ^0 + 1 \times 16^{-1} \\
				  &= 10 \times 16^3 + 14 \times 16 ^ 2 + 8 \times 16^1 + 6 \times 16 ^0 + 1 \times 16^{-1} \\
				  &= 40960 + 3584 + 128 + 6 + 0.0625 \\
				  &= 44678.0625D
\end{aligned}
$$

#### 二进制<->八、十六进制

> 二进制与八、十六进制之间互相有联系，二进制的三位就是八进制的一位，二进制的四位就是十六进制的一位

- 二进制转八进制

$$
\begin{aligned}
	(1111000010.01101)_2 &= \underline{001}\ \underline{111} \ \underline{000} \ \underline{010} \ . \ \underline{011} \ \underline{010} \\
						 &= (1702.32)_8
\end{aligned}
$$

- 二进制转十六进制

$$
\begin{aligned}
	(1111000010.01101)_2 &= \underline{0011}\ \underline{1100} \ \underline{0010} \ . \ \underline{0110} \ \underline{1000} \\
						 &= (3C2.68)_{16}
\end{aligned}
$$

- 对于八、十六进制转二进制，只需要逆着算就行

#### 十进制转任意进制

$$
\begin{aligned}
	K_nK_{n-1}...K_2K_1&K_0K_{-1}K_{-2}...K_{-m} \\
	= K_n \times r^n + K_{n - 1} \times r^{n-1} + ... + K_2 \times r^{2} + &K_1 \times r^1 + K_0 \times r^0 + K_{-1} \times r^{-1} + ... + K_{-m} \times r^{-m}
\end{aligned}
$$

- 十进制转任意进制需要分为两个部分：整数部分和小数部分

##### 整数部分

> 整数部分，取余

$$
\begin{aligned}
	\frac{K_n \times r^n + K_{n - 1} \times r^{n-1} + ... + K_2 \times r^{2} + K_1 \times r^1 + K_0 \times r^0}{r} = \underbrace{K_n \times r^{n - 1} + K_{n - 1} \times r^{n - 2} + ... + K_1 \times r^0}\limits_{商} ... \underbrace{K_0}\limits_{余数} 
\end{aligned}
$$

##### 小数部分

> 小数部分，取整

$$
\begin{aligned}
	(K_{-1} \times r^{-1} + ... + K_{-m} \times r^{-m}) \times r = \underbrace{K_{-1} \times r^0}\limits_{整数} + \underbrace{K_{-2} \times r^{-1} + ... + K_{-m} \times r^{-(m - 1)}}\limits_{小数}
\end{aligned}
$$

#### 十进制转二进制(拼凑法)

|  | $2^9$ | $2^8$ | $2^7$ | $2^6$ | $2^5$ | $2^4$ | $2^3$ | $2^2$ | $2^1$ | $2^0$ | $2^{-1}$ | $2^{-2}$ |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|  | 512 | 256 | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | 0.5 | 0.25 |
| 260.75 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 1 | 1 |

#### 真值和机器数

> 在日常生活中，通常用正负号来表示正负数，如$+15, -8$等。这种带正负号的数值被称为真值，真值是机器数代表的实际值
> 而在计算机中，通常将数的符号和数值部分一起编码，将数据的符号数字化，通常用“0”表示“正”，“1”表示“负”。这种把符号“数字化”的数称为机器数。常用原反补表示法

| 真值 | 机器数 |
| :---: | :---: |
| +15 | 0 1111 |
| -8 | 1 1000 |


### BCD码

> 二进制编码的十进制数(Binary-Coded Decimal, BCD)通常采用四位二进制数来表示一位十进制数中的0~9这十个数码。这种编码方式使二进制数和十进制数之间的转换得以快速进行。但是四位二进制数可以组合16种代码，因此有6种状态为冗余状态

#### 8421码

> 8421码是一种有权码，也是最为常用的编码。

$$
	D = 8b_3 + 4b_2 + 2b_1 + 1b_0
$$
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 |

- 如果两个8421码相加之和小于等于$(1001)_2$即$(9)_{10}$，则不需要修正，如果大于则需要修正，**修正方式为直接加上6即可，并向高位进位**

#### 余3码

> 余3码是一种无权码，其有8421码的基础上加上$(0011)_2$得来的

$$
	D_{余3码} = D_{8421} + 0011_2
$$

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 | 1010 | 1011 | 1100 |

#### 2421码

> 2421码是一种有权码，其特点是**大于等于5的四位二进制种最高位是1，小于5的最高位是0**

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 0000 | 0001 | 0010 | 0011 | 0100 | 1011 | 1100 | 1101 | 1110 | 1111 |

### 定点整数

> 数据的存储在计算机中使用原反补码的形式来存储
> 正数的原反补码是一致的
> 负数的反码是除符号位以外的位全部取反
> 负数的补码是反码加一

- 原反补码的书面表示

$$
\begin{aligned}
	\left[x\right]_{原} = \underbrace{1}\limits_{符号位},\underbrace{0011}\limits_{数据位} \\
	\left[x\right]_{反} = \underbrace{1}\limits_{符号位},\underbrace{1100}\limits_{数据位} \\
	\left[x\right]_{补} = \underbrace{1}\limits_{符号位},\underbrace{1101}\limits_{数据位}
\end{aligned}
$$

- 可以看见，在书面表示中，**可以使用逗号将数据位的数据分割开来**，如果在位数没有要求的情况下，甚至可以将无效位数省略$\left[x\right]_{原} = \underbrace{1}\limits_{符号位},\underbrace{11}\limits_{数据位}$

#### 原补的定义

- 纯小数的原码定义

$$
\left[x\right]_{原}=\left\{\begin{array}{}
	x & 1 \gt x \ge 0 \\
	1 - x = 1 + |x| & 0 \ge x \gt -1
\end{array}\right. \tag{[x]是原码机器数，x是真值} 
$$

- 纯整数的原码定义

$$
\left[x\right]_{原}=\left\{\begin{array}{}
	0,x & 2^n \gt x \ge 0 \\
	2^n - x = 2^n + |x| & 0 \ge x \gt -2^n
\end{array}\right. \tag{x+是真值，n是整数位数} 
$$

- 纯小数的补码定义

$$
\left[x\right]_{补}=\left\{\begin{array}{}
	x & 1 \gt x \ge 0 \\
	2 + x = 2 - x & 0 \gt x \ge -1
\end{array}\right. \tag{mod 2} 
$$

- 纯整数的补码定义

$$
\left[x\right]_{补}=\left\{\begin{array}{}
	0,x & 2^n \gt x \gt 0 \\
	2^{n+1} + x = 2^{n+1} - |x| & 0 \ge x \ge -2^n
\end{array}\right. 
$$

#### 原码与补码的另一种方式

> 我们知道，补码是原码取反后加一得到的，但是从补码回到原码往往是头疼的事情，因此，有另一种方法可以简单的从补码变为原码

- **补码从右往左数的第一位“1”的左边(除符号位以外)取反即可得到原码，原码也是如此**

$$
\begin{aligned}
	\left[x\right]_{原} = 1, 001001\underline{1} \rightarrow \left[x\right]_{补} = 1,\underline{110110}1 \\
	\left[x\right]_{原} = 1, \underline{001001}1 \leftarrow \left[x\right]_{补} = 1,110110\underline{1}
\end{aligned}
$$

- **补码的数值位不能解读为“位权”**

#### 补码的相反数的另一种方式

> 很多时候，我们也会遇见正数和负数的减法，那么对于负数，我们是先要求取补码，但是求取两次过于麻烦了，那么就有一种新的方式

$$
	\left[x\right]_{补} \mathop{\longleftrightarrow}\limits^{全部位按位取反、末位加一} \left[-x\right]_{补}
$$

- Eg.

$$
\begin{aligned}
	x = 19 \quad \left[x\right]_{补} = 0,0010011 \mathop{\longrightarrow}\limits^{全部位}_{按位取反} 1,1101100 \mathop{\longrightarrow}\limits^{末位+1} 1,1101101 \\
	-x = -19 \quad \left[x\right]_{补} = 1,1101101 \mathop{\longrightarrow}\limits^{全部位}_{按位取反} 0,0010010 \mathop{\longrightarrow}\limits^{末位+1} 0,0010011
\end{aligned}
$$

#### 移码

> 移码常用来表示浮点数的阶码。**其只能表示整数**

- 移码就是在真值X上加上一个常数(偏置值)，通常这个常数取$2^n$，相当于X在数轴上向正方向偏移了若干单位。

$$
	\left[x\right]_{移} = 2^n + x(2^n \gt x \ge -2^n，其中机器字长位n + 1)
$$
- 移码的特点：
	- **移码中零的表示唯一**，$\left[+0\right]_{移} = 2^n + 0 = \left[-0\right]_{移} = 2^n - 0 = 100...0(n个0)$
	- **一个真值的移码和补码仅差一个符号位，也就是说，补码的符号位取反就是移码**
	- 移码保持了数据原有的大小顺序，移码大真值就大

| 真值(十进制) | 补码 | 移码 |
| :---: | :---: | :---: |
| -128 | 1000 0000 | 0000 0000 |
| -127 | 1000 0001 | 0000 0001 |
| -126 | 1000 0010 | 0000 0010 |
| ... | ... | ... |
| -2 | 1111 1110 | 0111 1110 |
| -1 | 1111 1111 | 0111 1111 |
| 0 | 0000 0000 | 1000 0000 |
| 1 | 0000 0001 | 1000 0001 |
| 2 | 0000 0010 | 1000 0010 |
| ... | ... | ... |
| 126 | 0111 1110 | 1111 1110 |
| 127 | 0111 1111 | 1111 1111 |

#### 基本特性总结

| n+1 bit | 合法表示范围 | 最大的数 | 最小的数 | 真值0的表示 |
| :---: | :---: | :---: | :---: | :---: |
| 带符号整数：原码 | $-(2^n-1) \le x \le 2^n-1$ | $0,111...111 = 2^n-1$ | $1,111...111 = -(2^n-1)$ | $\begin{aligned}\left[+0\right]_{原} = 0,000...000\\ \left[-0\right]_{原} = 1,000...000\end{aligned}$ |
| 带符号整数：反码 | $-(2^n-1) \le x \le 2^n-1$ | $0,111...111 = 2^n-1$ | $1,000...000 = -(2^n-1)$ | $\begin{aligned}\left[+0\right]_{反} = 0,000...000\\ \left[-0\right]_{反} = 1,111...111\end{aligned}$ |
| 带符号整数：补码 | $-2^n \le x \le 2^n-1$ | $0,111...111 = 2^n-1$ | $1,000...000 = -2^n$ | $\begin{aligned}\left[0\right]_{补} = 0,000...000\\ 真值0只有一种补码\end{aligned}$ |
| 带符号整数：移码 | $-2^n \le x \le 2^n-1$ | $1,111...111 = 2^n-1$ | $0,000...000 = -2^n$ | $\begin{aligned}\left[0\right]_{移} = 1,000...000\\ 真值0只有一种补码\end{aligned}$ |
| 无符号整数 | $0 \le x \le 2^{n+1}-1$ | $1,111...111 = 2^{n+1}-1$ | $0000...000 = 0$ | $0000...000$ |

- 原反补移总结：
	- 原反补的符号位相同，正数的机器码相同
	- 原反码的表示在数轴上对称，**二者都存在+0和-0**
	- 补码、移码的表示在数轴上不对称，**零表示唯一**
	- 整数的补码、移码的符号位相反，数值位相同
	- 负数的反码、补码末位相差一
	- **对于负数，数值部分越大，绝对值越小，真值越大(越靠近0)**

| 行数 | 机器数 | 无符号数 | 原码 | 反码 | 补码 | 移码 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | 
| 1 | 0000 0000 | 0 | +0 | +0 | +0、-0 | -128 |
| 2 | 0000 0001 | 1 | +1 | +1 | +1 | -127 |
| ... | ... | ... | ... | ... | ... | ... |
| 126 | 0111 1101 | 125 | +125 | +125 | +125 | -3 |
| 127 | 0111 1110 | 126 | +126 | +126 | +126 | -2 |
| 128 | 0111 1111 | 127 | +127 | +127 | +127 | -1 |
| 129 | 1000 0000 | 128 | -0 | -127 | -128 | 0 |
| 130 | 1000 0001 | 129 | -1 | -126 | -127 | 1 |
| 131 | 1000 0010 | 130 | -2 | -125 | -126 | 2 |
| ... | ... | ... | ... | ... | ... | ... | ... |
| 255 | 1111 1110 | 254 | -126 | -1 | -2 | 126 |
| 256 | 1111 1111 | 255 | -127 | -0 | -1 | 127 |

### 定点小数

> 定点小数和定点整数一样，只是定点小数的小数点，固定在符号位之后

| n+1 bit | 合法表示范围 | 最大的数 | 最小的数 | 真值0的表示 |
| :---: | :---: | :---: | :---: | :---: |
| 定点小数：原码 | $-(1 - 2^n) \le x \le 1 - 2^n$ | $0,111...111 = 1 - 2^n$ | $1,111...111 = -(1 - 2^n)$ | $\begin{aligned}\left[+0\right]_{原} = 0,000...000\\ \left[-0\right]_{原} = 1,000...000\end{aligned}$ |
| 定点小数：反码 | $-(1 - 2^n) \le x \le 1 - 2^n$ | $0,111...111 = 1 - 2^n$ | $1,000...000 = -(1 - 2^n)$ | $\begin{aligned}\left[+0\right]_{反} = 0,000...000\\ \left[-0\right]_{反} = 1,111...111\end{aligned}$ |
| 定点小数：补码 | $-1 \le x \le 1 - 2^n$ | $0,111...111 = 1 - 2^n$ | $1,000...000 = -1$ | $\begin{aligned}\left[0\right]_{补} = 0,000...000\\ 真值0只有一种补码\end{aligned}$ |

### 奇偶校验码

> 奇偶校验用于检测数据传输过程中是否发生错误

#### 检验原理

- 在原位数上，增加一位用于检验，则就有$2^{n-1}$个冗余的非法状态

#### 奇偶校验码

> 整个校验码中“1”的个数为奇数则是奇校验码
> 整个校验码中“1”的个数为偶数则是偶校验码

![[奇偶校验.png]]

- 如果想要求出数码对应的奇偶校验，那么直接进行增加对应即可

##### 偶校验的硬件实现

- 各信息进行异或(模2加)运算，得到的结果即为偶校验位

$$
\begin{aligned}
	x_1 = 1 \bigoplus 0 \bigoplus 0 \bigoplus 1 \bigoplus 1 \bigoplus 0 \bigoplus 1 = 0 \\
	x_2 = 1 \bigoplus 0 \bigoplus 1 \bigoplus 0 \bigoplus 1 \bigoplus 1 \bigoplus 1 = 1
\end{aligned}
$$
> 可以见看，编码$1001101$的偶校验位$x_1 = 0$,则其偶校验码为$01001101$
> 编码$1010111$的偶校验位$x_2 = 1$,则其偶校验码为$11010111$

### 运算方法和运算电路

#### 一位全加器

> 全加器(FA)是最基本的加法单元，有加数$A_i$和加数$B_i$与低位传来的进位$C_{i-1}$共三个输入，有本位和$S_i$与向高位进位的$C_i$两个输出

![[全加器.png]]

- 全加器的逻辑表达式为：

$$
\begin{aligned}
	S_i &= A_i \bigoplus B_i \bigoplus C_{i-1} \\
	C_i &= A_iB_i + (A_i \bigoplus B_i)C_{i-1}
\end{aligned}
$$

![[全加器逻辑电路.png]]

##### 串行加法器

> 只有一个全加器，数据逐位串行送入加法器中进行运算，进位触发器用来存储进位信号，以便参加下一次运算

![[串行全加器.png]]

- 如果操作数长n位，加法就要分n次进行，每次产生一位和，并且串行逐位地送回寄存器

##### 串行进位加法器

> 串行进位加法器：把n个全加器串接起来，就可以进行两个n位数的相加。**串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，即进位信号是逐级形成的**

$$
\begin{aligned}
	A &= A_nA_{n-1}...A_1 \qquad B = B_nB_{n-1}...B_1 \\
	S &= S_nb_{n-1}...S_1 \qquad C = C_n
\end{aligned}
$$

![[串行进位全加器.png]]

- 串行进位加法器中，低位运算产生进位所需的时间将影响高位运算的时间。因此，**串行进位加法器的最长运算时间主要是由进位信号的传递时间决定的，位数越多延迟时间就越长，且全加器本身求和延迟很低，所以加快进位产生和提高传递的效率才是关键**

##### 并行加法器

> 我们通过串行进位加法器知道，位数越多，进位延迟越高，因此，并行加法器就是为了解决传递延迟问题

- 当我们对串行进位加法器的逻辑表达式进行分析：

$$
\begin{aligned}
	C_i &= A_iB_i + (A_i \bigoplus B_i)C_{i-1} \\
	C_i &= A_iB_i + (A_i \bigoplus B_i)(A_{i-1}B_{i-1} + (A_{i-1} \bigoplus B_{i-1})C_{i-2}) \\
	&..... \\
	Ci &= A_iB_i + (A_i \bigoplus B_i)(A_{i-1}B_{i-1} + (A_{i-1} \bigoplus B_{i-1})...C0)
\end{aligned}
$$
- 可以发现，第$i$位向更高位的进位$C_i$可根据被加数、加数的第$1~i$位再结合$C_0$确定
- 那么此时，我们约定$G_i = A_iB_i \qquad P_i = A_i \bigoplus B_i$

$$
\begin{aligned}
	C_i &= A_iB_i + (A_i \bigoplus B_i)C_{i-1} = G_i + P_iC_{i-1} \\
	\\
	C_1 &= G_1 + P_1C_0 \\
	C_2 &= G_2 + P_2C_1 = G_2 + P_2G_1 + P_2P_1C_0 \\
	C_3 &= G_3 + P_3C_2 = G_3 + P_3P_2G_1 + P_3P_2P_1C_0 \\
	&.... \\
	C_i &= G_i + P_iC_{i-1} = G_i + P_iP_{i-1}...P_2G_1 + P_iP_{i-1}...P_1C_0
\end{aligned}
$$
- 我们将$G_i = A_iB_i$称为进位产生函数(本地函数)
- 将$P_i = A_i \bigoplus B_i$称为进位传递函数(进位传递条件)，可以看出，$C_i$仅与$A_i \ B_i$以及最低进位$C_0$有关，互相之间的进位没有依赖关系。
- 实现上述逻辑表达式的电路被称为先行进位(也称超前进位)部件，简称CLA部件，而依据这种进位方法实现的加法器被称为全先行进位加法器

![[全先行进位加法器.png]]

- 虽然这种进位方式是快速的，与位数就没了关系，但是随着加法器位数的增加，$C_i$的逻辑表达式会变得异常复杂，**所以，位数多的时候采用全先行进位是不现实的**
- 因此，**我们可以通过多个CLA部件串行进位，组内采用先行进位的方式，就能够使得综合考虑上最为合适的方式，采用两级或多级先行进位加法器**

#### 算数逻辑单元ALU

> ALU是一种功能较强的组合逻辑电路，能够进行多种算术运算和逻辑运算。**由于加减乘除运算最终都能归结为加法运算，因此ALU的核心是带标志加法器**

![[ALU.png]]

- A、B是两个n位操作数输入端
- $C_{in}$是进位输入端，$C_{out}$是最高位进位输出端
- $ALU_{op}$是选择功能执行，可选项有加减乘除等算数运算和与或非等逻辑运算，**$ALU_{op}$的位数决定了操作的种类**

##### 加法器原理

> 加法器内部是一系列的全先行进位加法器

![[加法器.png]]

- 可以看见的是，加法器有
	- 两个加数输入端和一个低位进位输入端
	- 一个结果输出端和一个最高位进位输出端

$$
Eg.
\begin{aligned}
	A = 1000, B = 0111, C_{in} = 0 \Rightarrow F = 1111, C_{out} = 0 \\
	A = 1000, B = 0111, C_{in} = 1 \Rightarrow F = 0000, C_{out} = 1
\end{aligned}
$$

- 但是，我们发现，**这种加法器，只能针对原码进行计算，如果涉及到补码，就无法进行有效计算**

##### 补码加法器运算

> 在之前我们已经了解了$-\left[x\right]_{补} = \left[-x\right]_{补}$，并且对于补码的计算，计算机通常是利用加法计算

![[补码加法器.png]]

- 可以看见，我们在加数上增加一个多路选择器MUX，该选择器会判断，补码的正负从而进行相应操作
	- 如果是正数，那么就不需要进行额外操作直接进行加法
	- 如果是负数，那么就将该补码全部取反后，向$C_{in}$送上高电平表示末位加一，然后进行加法

- Eg. 4bit补码，$X = -8， Y = 7, X_{补} = 1000， Y_{补} = 0111$
$$
\begin{aligned}
	X + Y &= X_{补} + Y_{补} = 1111B = -1D \\
	X - Y &= X_{补} + (-Y_{补}) \\ 
		  &= 1000B + (1000 + 1)B \\ 
		  &= \mathop{\underline{1}}\limits_{舍去}0001 = 1D
\end{aligned}
$$

- 但是，**如果我们使用无符号整数进行计算，那么结果又不符合预期**。就比如，示例中$X = 3, Y = 4, X - Y = 15D$，这显然是不正常的。
- 因此我们引入了，标志位

##### 标志位生成

> 为了让加法器能够在一套电路上同时实现无符号和有符号的计算，因此在加法器上增加了相应的逻辑门电路

![[带标志位加法器.png]]
- 注：此处为了方标，图示上的FA应该使用先行进位方式

| 标志位 | 含义 | 计算方法 | 注意 |
| :---: | :---: | :---: | :---: |
| OF(Overflow Flag) | 有符号的加减运算是否发生了溢出 | $OF = C_n \bigoplus C_{n-1}$(最高位产生的进位异或次高位的进位) | OF位与无符号数的加减法无意义 |
| SF(Sign Flag) | 有符号数加减运算的正负性。$SF = 0$表示正数 | $SF = S_n$(最高位的本位和) | SF位对无符号数的加减法无意义 |
| ZF(Zero Flag) | 表示运算结果是否位0。$ZF = 1$表示结果为0 | 两个数的运算结果为$nbit$，当$nbit$全为0时，$ZF = 1$ |  |
| CF(Carry Flag) | 进位/借位标志，表示无符号数的加减法是否发生了进位或借位。$CF = 1$说明发生了 | $CF = C_n \bigoplus sub$(最高位进位异或sub) | CF位对有符号数的加减法无意义 |

- 通过这样，就能够完成一个通用的加法器了

### 定点数的位移运算

#### 算术移位

> 算术移位的对象是有符号数，在移位过程中符号位保持不变

- 对于正数，由于$\left[x\right]_{原} = \left[x\right]_{反} = \left[x\right]_{补} = 真值$，**因此移位后出现的空位均以0添之**。对于负数，由于原反补的表示形式不同，因此得单独计算规则
- **不论是正数还是负数，算术移位后其符号位均不变，且移位后都相当于对真值补0**

- 对于负数的反码来说，其移位后填1
- 对于负数的补码来说，找到从右至左的第一位1，然后作为分界线，右边的添0，左边添1

$$
	\left[x\right]_{补} = 1,\underbrace{1101}\limits_{同反码规则}\underbrace{100}\limits_{同原码规则}
$$
- 不同机器数算数移位后的空位填补规则

|  | 码制 | 填补代码 |
| :---: | :---: | :---: |
| 正数 | 原码、反码、补码 | 0 |
| 负数 | 原码 | 0 |
| 负数 | 反码 | 1 |
| 负数 | 补码 | 左移填0、右移填1 |

#### 逻辑移位

> 逻辑移位将操作数视为无符号数

- 位移规则：**逻辑左移，高位移丢，低位填0; 逻辑右移，低位移丢，高位填0**

#### 循环移位

> 循环移位分为带标志位CF的循环移位(大循环)和不带标志位的循环移位(小循环)

![[循环移位.png]]

- 其符号位参与移位
- **循环移位操作特别适合将数据的低字节数据和高字节数据互换**

### 定点数的乘除运算

> 在开始之前，我们需要了解一个东西：溢出判别方法，其常用于补码

#### 溢出判别方法

> 仅当两个符号相同的数相加或两个符号相异的数相减才可能产生溢出

##### 采用一位符号位

> 由于减法运算在机器中使用加法器实现的，**因此无论是加法还是减法，只要参加操作的两个数符号相同，结果又与原操作数符号不同，则结果溢出**

- 设A的符号为$A_s$，B的符号为$B_s$，运算结果的符号为$S_s$，则溢出表达式为

$$
	V = A_sB_s\overline{S_s} + \overline{A_sB_s}S_s
$$
- 若$V = 0$，则表示无溢出

##### 采用双符号位

> 双符号位也称模4补码。**运算结果的两个符号位$S_{s1}S_{s2}$相同。表示未溢出，且最高位符号位代表真正的符号**

- 溢出表达式为

$$
	V = S_{s1} \bigoplus S_{s2}
$$
- 比如$S_{s1}S_{s2} = 00$，表示结果为正数，且无溢出
- $S_{s1}S_{s2} = 10$，表示结果为负溢出

##### 采用一位符号位根据进位情况判断

> 若符号位的进位$C_s$与最高数位的进位$C_1$相同，则说明没有溢出。

- 溢出表达式为

$$
	V = C_{n} \bigoplus C_1
$$
- 若 $V = 0$ ，则说明无溢出

#### 乘法运算

> 乘法运算由累加和右移操作实现

##### 原码一位乘法

> 原码一位乘法的特点是符号位与数值位是分开求的，乘积符号是由两个数的符号位异或形成，而乘积的数值部分则是两个数的绝对值相乘之积

- 设$\left[x\right]_{原} = x_sx_1x_2...x_n, \left[x\right]_{原} = y_sy_1y_2...y_n$
	- 被乘数和乘数都以绝对值参加运算，其符号位为$x_s \bigoplus y_s$
	- 部分积是乘法过程中的中间结果。乘数的每一位$y_i$乘以被乘数得$X \times y_i$后，将该结果与前面所得结果累加
	- 从乘数的最低位$y_n$开始，若$y_n = 1$，则部分积加上被乘数$|x|$，然后右移一位，若$y_n = 0$，则部分积加上0，然后右移一位
	- 重复上一步步骤
- 由于参与运算的两个数是取绝对值，**因此运算过程中的右移操作均为逻辑右移**

![[原码一位乘法.png]]

###### 无符号数乘法运算电路

![[无符号乘法电路.png]]

- 实际上，由于乘法会导致进位的情况，所以一般我们会将最后的结果分为两部分，**乘法的高位放置在ACC寄存器中，低位放置在MQ寄存器中**
- 将部分积的结果放置在ACC寄存器中，用于每一次的部分积累加，而**ACC和MQ寄存器联合，用于保存整体结果**，每一次得到部分积后，都会**整体逻辑右移一位**，然后在**MQ中的最后一位作为当前参与乘法的位**
- 而C就是用于保存部分积和被乘数X可能产生进位的地方

##### 补码一位乘法

> 原码一位乘法只能对无符号数进行操作，而补码能够对有符号进行操作
> **补码一位乘法**使用双符号位参与运算

- 设$\left[x\right]_{补} = x_sx_1x_2...x_n， \left[x\right]_{补} = y_sy_1y_2...y_n$
	- **符号位参与运算，运算的数均以补码表示**
	- 被乘数通常取双符号位参与运算，部分积取双符号位，乘数取单符号位
	- 乘数末位增设附加位$y_{n+1}$，该位和原码乘法的符号位一起表示双符号位
	- 根据$(y_ny_{n+1})$的取值来确定操作
	- 移位按补码右移规则进行(符号位是什么就添什么)
	- 按照上述进行$n+1$步操作，但$n+1$步不再移位，也就是说，**比原码乘法多一次加法**

![[补码一位乘法.png]]

###### 有符号数乘法电路

![[有符号乘法电路.png]]

- 和原码乘法一样的，但是可以注意到的是**补码乘法在Y寄存器处多了一位辅助位**
- 补码乘法的符号是由Y寄存器中移除的最低位和前一位来决定是$-\left[x\right]_{补}、+\left[x\right]_{补}$还是$+0$

#### 除法运算

> 除法运算可转换成“累加 -- 左移”(逻辑左移)

##### 符号扩展

> 在算术运算中，有时必须把带符号的定点数转换成具有不同位数的表示形式。比如8位和32位相加，必须先将8位扩展为32位，再相加，这称为符号扩展

- 正数的符号扩展非常简单，即符号位不变，新表示形式的所有扩展位都用0进行填充
- 负数的符号扩展方法则根据机器数的不用而不同
	- 原码表示负数的符号扩展与正数相同。
	- 补码表示负数的符号扩展：原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用1(对于整数)或0(对于小数)进行填充

##### 原码恢复余数法

- 符号位单独处理，$x_s \bigoplus y_s$
- 在除法中，我们将ACC用作被除数和余数的寄存器，MQ用作商，还有一个通用寄存器表示除数
- 在MQ中的最后一位，就是我们要取的每一位商，商默认是1，如果发现余数是负数，就说明商大了，改商为0，恢复余数，然后计算得到余数，$余数 = 上一次余数 - 除数 * 商$
- ACC和MQ作为整体，逻辑左移
- 重复上述步骤

![[原码恢复余数法.png]]

##### 原码不恢复余数法

> 原码不恢复余数法也称为原码加减交替除法。**特点是商符和商值是分开进行的，减法操作用补码加法实现，商符由两个操作数的符号位“异或”形成**

- 我们发现，当恢复余数法中余数如果为负数，需要将商改为0，然后加上除数，左移后再减去除数，那么，**假若余数为负数的时候，直接将商改为0左移后加上除数，得到的效果和恢复余数法一致**，但是省略了恢复余数的步骤，因此，我们将该操作记作不恢复余数法

![[原码不恢复余数法.png]]

- 注意：**原码除法的余数和被除数是同号的，且步骤是左移$n$次，加减$n+1$次，余数需要乘上$2^{-n}$**

##### 补码除法

> 补码除法的特点，**符号位与数值位一起参与运算，商符自然形成。除法第一步根据被除数和除数的符号决定加法还是减法**

- **符号位参与运算，除数与被除数军用补码表示，商和余数也用补码表示**
- 若**被除数与除数同号，则被除数减去除数，若异号，则加上除数**
- 若**余数与除数同号，则商上1，余数左移一位减去除数，若异号，则商上0，余数左移一位加上除数**
- 若对商的精度没有要求，**一般采用末位恒置1法，误差不会超过$2^{-n}$**

###### 除法运算电路

![[除法电路.png]]

- R寄存器存放扩展被除数的高位，Q存放被除数的低位

##### 除法总结

| 除法类型 | 符号位参与运算 | 加减次数 | 移位方向 | 移位次数 | 上商、加减原则 | 说明 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 原码加减交替 | 否 | $N + 1$ 或 $N + 2$ | 左 | $N$ | 余数的正负 | 若最终余数为负，需恢复余数 |
| 补码加减交替 | 是 | $N+1$ | 左 | N | 余数和除数是否同号 | 商末位恒置1 | 

### C语言类型转换

#### 有符号数与无符号数的转换

> C语言中允许在不同数据类型之间做强制类型转换。但是，**C语言中，强制类型转换其实是一个不安全的事情，它会使得数据变化，以及内存冲突等等**

> [!tip] 首先，我们需要了解的是，**强制类型转换是一个临时变化**

``` c
int main() {
	int a = 10;
	unsigned int b = (unsigned int)a;
	return 0;
}
```

- 看上述代码中，a经过强制类型转换赋值给b，但实际上，如果我们观察一下就能发现，**a的值并未更改，也就是说，实际上，强制类型转换作用在了一个看不见的变量上**。
- 因此，我们得出一个结论，**C语言强制类型转换是产生了中间变量的**

``` c
int main() {
	short int x = -4321;
	unsigned short int y = (unsigned short int)x;
	return 0;
}
```

- 那么，我们再看上面一个代码，此时的变量x是一个short int类型的有符号负数，经过强制类型转换为无符号数后，我们发现$x = -4321, y = 61215$，x的值是没有发生变化的，但是y却变为了61215
- 此时，我们将x、y的补码展现出来，看一看是否有什么不同

$$
	x = 1110,1111,0001,1111B \quad y = 1110,1111,0001,1111B
$$
- 可以发现，x、y的补码并无不同，显然问题就是出现在了类型属性上，也就是说，x是有符号的short int类型，而y是无符号的short int类型，**y将首位的符号位解释为了数据位，这才导致了数据的不一致**
- 因此，得出的第二个结论，**C语言的数据表示需要根据类型来进行解释**

#### 不同字长整数转换(整形提升/截断)

> 在C语言中，赋值操作是十分常见的，有时我们会发现，当我们把一个int型数据赋值给char型的时候，编译器会提示我们，那么现在，就是来解释这一原因

```c
int main() {
	int x = 165537, u = -34991;
	short int y = (short int)x, v = (short int)u;
	return 0;
}
```

- 按理来说，x、u分别赋值给y、v，此时应该有$x = y、u = v$，但是实际上，我们发现，x、y和u、v的值是不相同的
- 那么我们将四个变量的值分别用十六进制表示 

$$
\begin{aligned}
	x &= 0x000286a1 \quad u = 0xffff7751 \\
	y &= 0x86a1 \qquad\quad v = 0x7751
\end{aligned}
$$

- 可以发现，x、y和u、v刚好是在低位对应的，但是由于x、u是4个字节，而y、v是2个字节的数据，因此高位被忽略导致了数据不同
- 因此，我们得出结论，**C语言中，高数据类型向低数据类型进行强制类型转换时，会发生截断现象**，所谓截断，就是将高位数据省略，低位数据直接赋值

```c
int main() {
	short int x = -4321;
	int y = x;
	return 0;
}
```

- 了解到截断之后，我们再来看一个例子。此时y经过赋值后，$y = -4321, x = -4321$，虽然表现出来的数据是一致的，但是我们从其底层的补码来看

$$
	x = 0xef1f \quad y = 0xffffef1f
$$
- 可以看见，**低数据类型向高数据类型赋值时，需要进行扩展，如果是无符号整数，则高位进行零扩展，否则进行符号扩展，也就是扩展的高位用原数字的符号位来填充**，而这种方式在C语言中叫做**整形提升**
- 因此，我们得出结论，**C语言中，低数据类型向高数据类型赋值时会发生整型提升**

### 数据的存储和排列

> 在存储数据时，数据从低位到高位可以按从左至右也可按从右至左排列。**因此，无法用最左或最右来表征数据的最高位或最低位，通常用最低有效字节(LSB)和最高有效字节(MSB)分别表示低位和高位**

- 例如，32位计算机中，一个int型变量i的机器数为$01 23 45 67H$，其中$MSB = 01H, LSB = 67H$

- 现代计算机基本上都采用字节编址，即每个地址编号中存放1字节。不同类型的数据占用的字节数不同，而程序中对每个数据只给定一个地址。
- **多字节数据都存放在连续的字节序列中，根据数据中个字节在连续字节序中的排列顺序不同，可以采用两种排列方式，大端方式(big endian)和小端方式(little endian)**

![[大小端方式.png]]

- 大端方式按**从最高有效字节到最低有效字节的顺序存储数据，即最高有效字节存放在前面**
- 小端方式按**最低有效字节到最高有效字节的顺序存储顺序，即最低有效字节存放在前面**

#### 判断大小端

> 在C语言中，常用判断大小端的方式为两种：指针和联合

```c
// 使用指针判断大小端模式
int check_sys() {
	int sys = 1; // 如果是小端，内存中应该是01 00 00 00H
	return *(char*)&sys; // 索取内存中的第一个字节信息，如果返回1，则是小端
}

// 使用联合判断大小端模式
int check_sys() {
	union sys {
		char sys_c;
		int sys_i;
	}sys_d;
	sys_d.sys_i = 1; // 联合中共用内存，如果是小端，sys_c = 01H
	
	return sys_d.sys_c;
}
```

> 除了大小端，内存中的数据还有另外的存储方式，也就是“边界对齐”方式存储。

![[边界对齐.png]]

- 对于边界对齐，**采用了以空间换时间的方式，浪费了一些存储空间，但提高了取指令和取数的速度**
- 而边界不对其，则可以充分利用存储空间，但是需要多次访存，影响指令的执行效率

#### 内存对齐

> 在C语言中，有一些知识点就能反映出这一问题

- 在我们学习结构体时，我们经常发现，结构体的大小比我们算的大小往往不一致

```c
struct Data {
	char c;
	int i;
	double d;
};
```

- 如果我们就简单的使用 $sizeof(Data)$ 与 $sizeof(c) + sizeof(i) + sizeof(d)$进行对比，我们会发现，实际上是不相等的，因为**C语言结构体会涉及到内存对齐这一类似于边界对齐的知识**
- 在C语言中结构体的大小有一个公式

$$
struct_{size} =
\left\{
\begin{array}{}
	\sum_{i=0}^{n} sizeof(type_i) \\
	\frac{struct_{size}}{Min(对齐数, Min(sizeof(type_{max})))} = 0 \\
	对齐数与编译器实现有关 \\
	Min(对齐数,sizeof(type_{max}))为类型最大的数据
\end{array}
\right.
$$
- 也就是说，$sizeof(Data) = 16$

$$
\begin{aligned}
	sizeof(Data) &= 1 + \mathop{\underline{3}}\limits_{扩展了3字节} + 4 + 8 = 16 \\
	\frac {sizeof(Data)}{struct_i} &= 0 \\
	struct_i &= Min(8, sizeof(type_i))
\end{aligned}
$$

- 也就是说，结构体会默认一个**有效对齐数**，然后每次进行计算时，**结构体中的最大数据元素，会与对齐数进行比较，得到最小对齐数，如果偏移量(offset)不能整除最小对齐数，则进行扩展**

```c
struct Data {
	char c1;
	int i;
	char c2;
}
```

- 如果默认有效对齐数为4，用key记录最小对齐数，offset表示偏移量，data表示扩充数，那么：
	- 首先计算最小对齐数$key = min(4, sizeof(type_{max})) = 4$
	- 比较$sizeof(c1)$和4，$key = 1$，此时$\frac{sizeof(c1) + offset}{key} \ne 0$，则说明需要发生对齐，$offset = sizeof(c1) + offset + data且满足\frac{offset}{key} = 0$，因此$data = 3，offset = 4$
	- 比较$sizeof(i)$和4，$key = 4$，此时$\frac{sizeof(i) + offset}{key} \ne 0$，则说明需要发生对齐，$offset = sizeof(i) + offset + data且满足\frac{offset}{key} = 0$，因此$data = 3，offset = 8$
	- 比较$sizeof(c2)$和4，$key = 1$，此时$\frac{sizeof(c2) + offset}{key} \ne 0$，则说明需要发生对齐，$offset = sizeof(c2) + offset + data且满足\frac{offset}{key} = 0$，因此$data = 3，offset = 12$
	- 故 $struct_{size} = offset = 12$

##### 更改默认对齐数

> **由于C语言的编译器在不同平台上，有着不同的实现规则，为了跨平台不会出现错误，C语言提供了一个宏用于定制内存对齐的默认对齐数**

```c
struct D1 {
	char c1;
	int i;
	char c2;
};

#pragma pack(1) // 设置默认对齐数为1
struct D2 {
	char c1;
	int i;
	char c2;
};
#pragma pack() // 取消设置的默认，使得和编译器默认一致

#pragma pack(8)
struct D3 {
	char c1;
	int i;
	char c2;
};
#pragma pack()

#pragma pack(16)
struct Data {
	char c1;
	int i;
	char c2;
}
#pragma pack()
```

- 假定默认对齐数是4，那么经过#pragma pack(8)设置之后，默认对齐数就为8
$$
\begin{aligned}
	sizeof(D1) &= 12 \\
	sizeof(D2) &= 6 \\
	sizeof(D3) &= 12
\end{aligned}
$$
- **实际上，如果修改的默认对齐数大于了最大类型的字节数，其实是没有意义的**

$$
	sizeof(D4) = 12
$$

### 浮点数的表示与运算

#### 浮点数的表示

> 浮点数表示法是指以适当的形式将比例因子表示在数据中，让小数点的位置根据需要而浮动。

- 通常，浮点数表示为：

$$
	N = (-1)^S \times M \times R^E
$$
- S取值0或1，用来决定浮点数的符号，M是一个二进制定点小数，称为尾数，一般用定点原码小数表示，E是一个二进制定点整数，称为阶码或指数，用移码表示。R是基数

![[浮点数的表示法.png]]

- **阶码的值反应了浮点数的小数点的实际位置，阶码的位数反应浮点数的表示范围，尾数的位数反应浮点数的精度**

##### 表示范围

> 原码是关于原点对称的，故浮点数的范围也是关于原点对称的

![[浮点数的范围.png]]

- 运算结果大于最大整数时称为正上溢，小于绝对值最大负数时称为负上溢，正上溢和负上溢统称上溢。
- **数据一旦上溢，计算机必须中断运算操作，进行溢出处理**
- 当运算结果在0至最小正数之间称为正下溢，在0至绝对值最小负数之间称为负下溢，正下溢和负下溢统称下溢。
- **数据下溢时，浮点数值趋于零，计算机仅当其当作机器零处理**

##### 规格化

> 尾数的位数决定浮点数的有效位数，有效位数越多，数据的精度越高。**所谓规格化操作，是指通过调整一个非规格化浮点数的尾数和阶码大小，使非零的浮点数在尾数的最高数位上保证是一个有效值**

- 左规
	- 当运算结果的尾数的最高数位不是有效位，即出现 $\pm 0.0...0x...x$ 的形式时，需要进行左规。左规时，尾数每左移一位，阶码减一，直至尾数变为规格化形式为止

$$
	a = 2^2 \times 0.0101 = 2^1 \times 0.101
$$
- 右规
	- 当运算结果的尾数的有效位进到小数点前面时，需要进行右规。将尾数右移一位，阶码加一。

- 
$$
\begin{aligned}
	a + b &= 2^2 \times 00.1100 + 2^2 \times 00.1000 \\
		&= 2^2 \times (00.1100 + 00.1000) \\
		&= 2^2 \times 01.0100 \\
		&= 2^3 \times 00.1010
\end{aligned}
$$

- 原码表示规格化尾数$M$的绝对值应满足 $1/R \le |M| \le 1$。若$R = 2$，则有$1/2 \le |M| \le 1$
	- 正数为$0.1xx...x$的形式，其最大值表示为$0.11...1$，最小值表示为$0.100...0$。尾数表示范围为$1/2 \le M \le (1 - 2^{-n})$
	- 负数为$1.1xx...x$的形式，其最大值表示为$1.10...0$，最小值表示为$1.11...1$。尾数的表示范围为$-(1-2^(-n)) \le M \le -1/2$
- 基数不同，浮点数的规格化形式也不同。**当浮点数尾数的基数为2时，原码规格化数的尾数最高位一定是1**。

#### IEEE 754标准

> IEEE 754标准规定常用的浮点数格式有短浮点数(单精度、float型)、长浮点数(双精度、double型)、临时浮点数。

![[IEEE 754.png]]

| 类型 | 数符 | 阶码 | 尾数数值 | 总位数 | 十六进制 | 十进制 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 短浮点数 | 1 | 8 | 23 | 32 | 7FH | 127 |
| 长浮点数 | 1 | 11 | 52 | 64 | 3FFH | 1023 |
| 临时浮点数 | 1 | 15 | 64 | 80 | 3FFFH | 16383 |

- 对于规格化的二进制浮点数，数值的最高位总是“1”，**为了能使尾数多表示一位有效位，将这个“1”隐藏，称为隐藏位，因此23位尾数实际上表示了24位有效数字**

- 在IEEE 754标准中，规格化的短浮点数的真值为:

$$
	(-1)^S \times 1.M \times 2^{E-127}
$$
- 规格化长浮点数的真值为：

$$
	(-1)^S \times 1.M \times 2^{E-1023}
$$
