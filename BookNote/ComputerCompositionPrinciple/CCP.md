# 计算机组成原理

---

## 计算机系统概述

### 冯诺依曼体系结构

> 冯诺依曼提出了“存储程序”的概念，其思想奠定了现代计算机的基本结构

- 采用“存储程序”的工作方式
- 计算机硬件系统由运算器、存储器、控制器、输入输出设备这五大部件组成
- **指令和数据以同等地位存储在存储器中，形式上没有区别，但计算机能够区分**
- **指令和数据均采用二进制代码表示**。**指令由操作码和地址码组成，操作码指出操作的类型，地址码指出操作数的地址**
- **以运算器为中心** -> 现代计算机以存储器为中心

> “存储程序”的基本思想是：**将事先编好的程序和原始数据送入主存后才能执行，一旦程序被启动执行，就无须操作人员的干预，计算机会自动逐条执行指令，直至程序执行结束**

### 各个硬件的工作原理

#### 主存储器

> CPU能够**直接访问**的存储器是主存储器。**主存储器的工作方式是按存储单元的地址进行存取，这种存储方式称为按地址存取方式**

- 主存储器的最基本组成如下所示：
	- 存储体，存储体存放二进制信息
	- 数据存储寄存器(Memory Data Register)，MAR存放访存地址，经过地址译码后找到所选的存储单元
	- 地址存储寄存器(Memory Address Register)，MDR用于暂存要从存储器中读或写的信息
	- 时序逻辑控制器，用于产生存储器操作所需的各种时序信号

![[主存储器.png]]

##### 存储体

> 存储体由许多存储单元组成，每个存储单元包含若干存储元件，每个存储元件存储一位二进制代码0/1. 因此存储单元可以存储一串二进制代码，这串代码称为存储字，称这串代码的位数为存储字长

- 存储体
	- 存储单元：每个存储单元存放一串二进制代码
	- 存储字(word)：存储单元中二进制代码的组合
	- 存储字长：存储单元中二进制代码的位数
	- 存储元：即存储二进制的电子元件，每个存储元可存储1bit
- **每一个地址都对应一个存储单元**

| 地址 | 存储体 |
| :---: | :---: |
| 0 | 存储单元 |
| 1 | 存储单元 |
| 2 | ... |
| 3 | ... |
| 4 | ... |
| ... | ... |

##### MAR

> MAR用于寻址，**其位数对应着存储单元的个数**，如MAR为10位，则有$2^{10} = 1024$个存储单元。**MAR的长度和PC寄存器的长度相同**

##### MDR

> MDR的位数是存储单元的字长，假如MDR位16位，也就是说一个字的长度位16bit，每个存储单元可存放16bit的数据

> [!warning] 注意，**在现代CPU中，MAR和MDR是存在于CPU中的**

#### 运算器

> 运算器是计算机的执行部件，用于算术运算和逻辑运算。

- 运算器的基本组成如下：
	- 算术逻辑单元(ALU)
	- 寄存器，**前三个寄存器是必须的**
		- 累加寄存器(ACC)
		- 乘商寄存器(MQ)
		- 通用寄存器(X)
		- 变址寄存器(IX)
		- 基址寄存器(BR)
		- ....

- 寄存器作用表

| | 加 | 减 | 乘 | 除 |
| :---: | :---: | :---: | :---: | :---: |
| ACC | 被加数、和 | 被减数、差 | 乘积高位 | 被除数、余数 |
| MQ | | | 乘数、乘积低位 | 商 |
| X | 加数 | 减数 | 被乘数 | 除数 |

![[运算器.png]]

#### 控制器

> 控制器是计算机的指挥中心，使得各部件自动协调地进行工作。控制器由程序计数器(PC)、指令寄存器(IR)和控制单元(CU)组成

- 控制器的基本组成如下所示：
	- PC寄存器，用于**存放当前欲执行指令的地址(也就是下一条指令)**，当执行完毕后自动移动到下一条指令地址的开头。它与主存MAR之间由一条直接通路
	- IR寄存器，用来**存放当前的指令**，其内容来自主存的MDR。指令中的操作码OP(IR)送至CU，用以分析指令并发出各种微操作命令序列，而地址码Ad(IR)送往MAR，用以取操作数
	- CU控制单元，分析指令，给出控制信号

### 计算机的工作过程

![[计算机简单结构.png]]

#### 探究简单C语言代码执行逻辑

``` c
int main() {
	int a = 2, b = 3, c = 1, y = 0;
	y = a * b + c;
	return 0;
}
```

- 编译后装入主存后的结构示意图

| 主存地址 | 操作码 | 地址码 | 注释 |
| :---: | :---: | :---: | :---: |
| 0 | 000001 | 0000000101 | 取数a至ACC | 
| 1 | 000100 | 0000000110 | 乘b得ab，存于ACC中 | 
| 2 | 000011 | 0000000111 | 加c得$ab + c$，存于ACC中 | 
| 3 | 000010 | 0000001000 | 将$ab + c$存于主存单元 | 
| 4 | 000110 | 0000000000 | 停机 | 
| 5 | 000000 | 0000000101 | 原始数据$a=2$ | 
| 6 | 000000 | 0000000101 | 原始数据$b=3$ | 
| 7 | 000000 | 0000000101 | 原始数据$c=1$ | 
| 8 | 000000 | 0000000101 | 原始数据$y=0$ | 

##### 控制器的简单执行逻辑

1. $(PC) = 0x0$，PC寄存器指向第一条指令的存储地址
2. $MAR = (PC)$，MAR得到PC指向的主存地址
3. $(PC) = 0x1$，当PC寄存器执行完后，自动的访问下一条指令的地址
4. $M(MAR) = MDR$， MDR得到MAR指向的主存地址中的数据
5. $IR = (MDR)$，IR得到MDR中对应的指令，开始分析操作码OP(IR)和地址码AD(IR)
6. $CU = OP(IR)$，IR将分析得出的操作码送往CU，让CU分析对应的操作
7. $MAR = AD(IR)$，IR将分析得出的地址码送往MAR，找到需要执行的内存单元
8. 进行对应操作，重复2~8流程，直至程序结束

##### 指令执行过程

1. 取指令
	1. PC -> MAR -> M -> MDR -> IR
	2. 将PC取指令到IR，将PC中的内容送往MAR，MAR中的内容送往存储体中索取对应数据，主存通过地址线上的之地和读信号，从指定存储单元读出指令送到数据线上，MDR从数据线上接受指令信息，传送到IR中
2. 分析指令
	1. OP(IR) -> CU
	2. 指令译码并送出控制信号，控制器CU根据IR中指令的操作码，生成相应的控制信号，送到不同的执行部件
3. 执行指令
	1. AD(IR) -> MAR -> M -> MDR -> ACC
	2. 取数操作。将IR中指令的地址码送给MAR，MAR中的内容送入地址线，同时控制器将读信号送读/写信号线，从主存中取出操作数，并通过数据线送至MDR，再传送至ACC中
4. **每次读完指令，PC就会立即指向下一条指令的地址，$(PC) = (PC) + 1$

##### 代码的简单执行逻辑

1. $(PC) = 0x0$，PC寄存器指向第一条指令的存储地址
2. $MAR = (PC)$，使得$(MAR) = 0$，找到了主存地址为0的位置
3. $(PC) = (PC) + 1$，执行完后，PC指向下一条指令
4. $MDR = M(MAR)$，使得$(MDR) = 000001 0000000101$
5. $IR = (MDR)$，IR寄存器得到指令，开始分析，$OP(IR) = 0000001$，$AD(IR) = 0000000101$
6. $CU = OP(IR)$，将操作码送往CU，CU分析指令，得出是“取数”指令
7. $MAR = AD(IR)$，将地址码送往MAR，使得$(MAR) = 0x5$
8. $MDR = M(MAR)$，将对应地址码中的数据取出，存放在MDR中，使得$(MDR) = 0x2$
9. $ACC = (MDR)$，将MDR的数据送往ACC累加寄存器中，$(ACC) = 0x2$

- 上述步骤其实就是代码中的$int \ a = 2$语句，但是因为$y = a*b + c$的缘故，CPU决定将其送往ACC中，与后续的$b$做乘法后和$c$进行相加操作，因此才会存放在ACC中。

### 计算机系统的多级层次结构

> 计算机是一个软硬件组合的综合体。由于面对应用范围越来越广，必须有复杂的系统软件和硬件的支持。
> 计算机系统的多级层次结构的作用，**就是根据从各种角度所看到的机器之间的有机联系，来分清彼此之间的界面，明确各自的功能，以便构成合理、高效的计算机系统**

> [!warning] 计算机系统层次结构的分层方式，没有统一的标准

- 层次表

| 层次结构 | 用法 | 示例 |
| :---: | :---: | :---: | 
| 虚拟机器 $M4$(高级语言机器) | 用**编译程序翻译**成**汇编语言程序** | $y = a * b + c$ |
| 虚拟机器 $M3$(汇编语言机器) | 用**汇编程序翻译**成**机器语言程序** | LOAD $5$ |
| 虚拟机器 $M2$(操作系统机器) | 向上提供“广义指令”(系统调用) |  |
| 传统机器$M1$(用机器语言的机器) | 用微程序解释机器指令，执行二进制机器指令 | $0000010000000101$ |
| 微程序机器$M0$(微指令系统) | 由硬件直接执行微指令 | PC、IR等 |

- 第一级是微程序机器层，这是一个实在的硬件层
- 第二级是传统机器语言层，也是一个实际的机器层
- 第三级是操作系统层，其由操作系统程序实现，而**操作系统程序是由机器指令和广义指令组成的**，这些广义指令是为了扩展机器功能而设置的，由操作系统定义和解释的软件指令，所以这一层也称为混合层
- 第四层是汇编语言层，其为用户提供一种符号化的语言
- 第五层是高级语言层，其是面向用户的，是为了方便用户编写应用程序而设置的。
- **没有配备软件的纯硬件系统被称为裸机**，**第三层~第五层称为虚拟机**，也就是软件实现的机器，虚拟机器只对该层的观察者存在。
- **层次之间的关系紧密，下层是上层的基础，上层是下层的扩展**

#### 编译

> 将高级语言写的源程序全部语句一次性全部翻译为机器语言程序 -> 一次编译，处处运行
> 代表语言类似：C/C++

- 类似于C/C++的编译，需要经过四个步骤
	- 预处理
	- 编译
	- 汇编
	- 链接

#### 解释

> 将源程序的一条语句翻译为对应机器语言的语句，并立即执行，直至将程序翻译执行完毕 -> 一次翻译，一次运行
> 代表语言类似：Python、JavaScript

- 类似于Python的解释，只需要经过两个步骤
	- 解释
	- 执行

### 计算机的性能指标

#### 存储器的性能指标

> 存储器的性能指标就是主存容量，通俗的讲就是内存大小。**主存容量是指主存储器所能存储信息的最大容量，通常用字节来衡量**

- 主存容量的大小与**MAR和MDR**有关

$$ 
\begin{aligned} 
   &Memory = MAR * MDR \\ 
   eg. MAR = 2^{32}, &\ \ \ MDR = 8bit \rightarrow Memory = 2^{32} * 8bit = 4GB
\end{aligned} 
$$

#### CPU的性能指标

> CPU的性能指标通常和CPU的时钟周期、主频等有关。

##### CPU时钟周期

> 通常为节拍脉冲或T周期，即主频的倒数，它是CPU中最小的时间单位，**执行指令的每个动作至少需要一个时钟周期**

$$ CPU时钟周期 = \frac{1}{CPU主频}Hz $$

##### CPU主频

> CPU主频也被叫做CPU时钟频率。机器内部主时钟的频率，**是衡量机器速度的重要参数**。**对于同一个型号的计算机，其主频越高，完成指令的一个执行步骤所用的时间越短，执行指令的速度越快**

$$ CPU主频 = \frac{1}{CPU时钟周期}Hz $$

##### CPI(Clock cycle Per Instruction)

> CPI，即执行一条指令所需的时钟周期数。不同指令的时钟周期数可能不同，甚至同指令完成的时钟周期数也不同，**因此，一般来说，CPI指该程序或该机器指令集中所有的指令执行所需的平均时钟周期数，此时CPI是一个平均值**

$$ per\_cmd\_cost = CPI \times CPU时钟周期 $$

- Eg：某CPU主频为1000Hz，某程序包括100条指令，平均来看指令的$CPI = 3$。该程序在该CPU上执行需要多久？

$$ 答：time = 100 * CPI * \frac{1}{1000} = 0.3s $$

##### CPU执行时间

> 指运行一个程序所花费的时间

$$ CPU\_cost\_time = \frac{CPU时钟周期数}{主频} = \frac{指令条数 \times CPI}{主频} $$
- 上述表明，CPU的性能(执行时间)取决于三个要素：主频、CPI和指令条数
- 其中，主频、CPI和指令条数是相互制约的，更改指令集可以减少程序所含的指令条数，但可能引起CPU结构的调整，从而增加时钟周期的宽度(降低主频)。

##### IPS

> IPS - Instruction Per Second，即每秒执行的指令数

$$ IPS = \frac{主频}{CPI} $$
- 其中，对于每秒执行的指令数，不止有IPS，还有KIPS、MIPS

##### FLOPS

> FLOPS - Floating-point Operations Per Second，每秒执行多少次浮点运算，还有KFLOPS、MFLOPS、GFLOPS、TFLOPS

- 注意：IPS和FLOPS一样，K、M、G、T为数量单位，而非计算机的二进制，而是十进制

#### 系统整体的性能指标

> 系统整体性能指标，通常使用带宽和字长等来表示的

##### 字长

> 字长是指计算机进行一次整数运算(即定点整数运算)所能处理的二进制数据的位数，通常与CPU的寄存器位数、加法器有关。**因此，字长一般等于内部寄存器的大小，字长越长，数据的比爱是范围越大**

- 字：用来表示被处理信息的单位，用来度量数据类型的宽度
- 字长：指CPU内部用于整数运算的数据通路的宽度，反应了计算机处理信息的能力
- 机器字长：也就是字长
- 指令字长：一个指令字中包含的二进制代码位数，取决于操作码的长度
- 存储字长：一个存储单元存储的二进制代码长度

##### 数据通路带宽

> 数据通路带宽是指**数据总线一个所能并行传送信息的位数**，而此处所说的带宽是指外部数据总线的宽度，和CPU内部的数据总线宽度(内部寄存器)可能不同
> **各个子系统通过数据总线连接形成的数据传送路径称为数据通路**

##### 吞吐量

> **指系统在单位时间内处理请求的数量。其取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存中取出或存入，以及所得结果能多快地从内存中送给外部设备**。这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存储周期

##### 响应时间

> 指从用户像计算机发送一个请求，到系统对该请求做出相应并获得所需要结果的等待时间。

- 通常包括CPU时间(运行一个程序所花费的时间)与等待时间(用于磁盘访问、存储器访问、I/O操作、操作系统开销等)

##### 基准程序

> 专门用来进行性能评价的一组程序，能够很好地反映机器在运行实际负载时的性能，可以通过在不同机器上运行相同的基准程序来比较在不同机器上的运行时间，从而评测其性能

- 对于不同的场合，应该选取不同的基准程序
- 基准程序的性能存在缺陷。

### 习题

#### 题一

``` txt
冯诺依曼机的基本工作方式是()
A. 控制流驱动方式    B. 多指令多数据流方式
C. 微程序控制方式    D. 数据流驱动方式

答：A选项，控制流驱动方式。
```

## 数据的表示和运算

### 进位计数制

> 在计算机内部，所有信息都是二进制编码的
> 1. 二进制只有两种状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位，制造成本低。
> 2. 二进制位的1和0正好与逻辑值“真”和“假”对应，为计算机实现逻辑运算和程序中逻辑判断提供了便利条件
> 3. 二进制编码和运算规则简单，通过逻辑门电路能方便地实现算术运算

#### 十进制计数法

$$
\begin{aligned}
	K_nK_{n-1}...K_2K_1&K_0K_{-1}K_{-2}...K_{-m} \\
	= K_n \times 10^n + K_{n - 1} \times 10^{n-1} + ... + K_2 \times 10^{2} + &K_1 \times 10^1 + K_0 \times 10^0 + K_{-1} \times 10^{-1} + ... + K_{-m} \times 10^{-m}
\end{aligned}
$$

- 其中，10是基数，而$10^i$是第i位的权重

#### 推广->r进制计数法

$$
\begin{aligned}
	K_nK_{n-1}...K_2K_1&K_0K_{-1}K_{-2}...K_{-m} \\
	= K_n \times r^n + K_{n - 1} \times r^{n-1} + ... + K_2 \times r^{2} + &K_1 \times r^1 + K_0 \times r^0 + K_{-1} \times r^{-1} + ... + K_{-m} \times r^{-m}
\end{aligned}
$$

- 基数：每个数码位所用到的不同符号的个数，r进制的基数为r

#### 任意进制转十进制

> 对于任意进制转十进制来说，只需要将该进制每位上的数乘以其权重相加之和即可得到对应十进制

- 二进制转十进制

$$
\begin{aligned}
	(1001.11)_2 &= 1 \times 2^3 + 0 + 0 + 1 \times 2^0 + 1 \times 2^{-1} + 1 \times 2^{-2} \\
				&= 8 + 0 + 0 + 1 + 0.5 + 0.25 \\
				&= 9.75D
\end{aligned}
$$

- 八进制转十进制

$$
\begin{aligned}
	(251.5)_8 &= 2 \times 8^2 + 5 \times 8^1 + 1 \times 8^0 + 5 \times 8^{-1} \\
			  &= 128 + 40 + 1 + 0.625 \\
			  &= 169.625D
\end{aligned}
$$

- 十六进制转十进制

$$
\begin{aligned}
	(AE86.1)_{16} &= A \times 16^3 + E \times 16 ^ 2 + 8 \times 16^1 + 6 \times 16 ^0 + 1 \times 16^{-1} \\
				  &= 10 \times 16^3 + 14 \times 16 ^ 2 + 8 \times 16^1 + 6 \times 16 ^0 + 1 \times 16^{-1} \\
				  &= 40960 + 3584 + 128 + 6 + 0.0625 \\
				  &= 44678.0625D
\end{aligned}
$$

#### 二进制<->八、十六进制

> 二进制与八、十六进制之间互相有联系，二进制的三位就是八进制的一位，二进制的四位就是十六进制的一位

- 二进制转八进制

$$
\begin{aligned}
	(1111000010.01101)_2 &= \underline{001}\ \underline{111} \ \underline{000} \ \underline{010} \ . \ \underline{011} \ \underline{010} \\
						 &= (1702.32)_8
\end{aligned}
$$

- 二进制转十六进制

$$
\begin{aligned}
	(1111000010.01101)_2 &= \underline{0011}\ \underline{1100} \ \underline{0010} \ . \ \underline{0110} \ \underline{1000} \\
						 &= (3C2.68)_{16}
\end{aligned}
$$

- 对于八、十六进制转二进制，只需要逆着算就行

#### 十进制转任意进制

$$
\begin{aligned}
	K_nK_{n-1}...K_2K_1&K_0K_{-1}K_{-2}...K_{-m} \\
	= K_n \times r^n + K_{n - 1} \times r^{n-1} + ... + K_2 \times r^{2} + &K_1 \times r^1 + K_0 \times r^0 + K_{-1} \times r^{-1} + ... + K_{-m} \times r^{-m}
\end{aligned}
$$

- 十进制转任意进制需要分为两个部分：整数部分和小数部分

##### 整数部分

> 整数部分，取余

$$
\begin{aligned}
	\frac{K_n \times r^n + K_{n - 1} \times r^{n-1} + ... + K_2 \times r^{2} + K_1 \times r^1 + K_0 \times r^0}{r} = \underbrace{K_n \times r^{n - 1} + K_{n - 1} \times r^{n - 2} + ... + K_1 \times r^0}\limits_{商} ... \underbrace{K_0}\limits_{余数} 
\end{aligned}
$$

##### 小数部分

> 小数部分，取整

$$
\begin{aligned}
	(K_{-1} \times r^{-1} + ... + K_{-m} \times r^{-m}) \times r = \underbrace{K_{-1} \times r^0}\limits_{整数} + \underbrace{K_{-2} \times r^{-1} + ... + K_{-m} \times r^{-(m - 1)}}\limits_{小数}
\end{aligned}
$$

#### 十进制转二进制(拼凑法)

|  | $2^9$ | $2^8$ | $2^7$ | $2^6$ | $2^5$ | $2^4$ | $2^3$ | $2^2$ | $2^1$ | $2^0$ | $2^{-1}$ | $2^{-2}$ |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|  | 512 | 256 | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | 0.5 | 0.25 |
| 260.75 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 1 | 1 |

#### 真值和机器数

> 在日常生活中，通常用正负号来表示正负数，如$+15, -8$等。这种带正负号的数值被称为真值，真值是机器数代表的实际值
> 而在计算机中，通常将数的符号和数值部分一起编码，将数据的符号数字化，通常用“0”表示“正”，“1”表示“负”。这种把符号“数字化”的数称为机器数。常用原反补表示法

| 真值 | 机器数 |
| :---: | :---: |
| +15 | 0 1111 |
| -8 | 1 1000 |


### BCD码

> 二进制编码的十进制数(Binary-Coded Decimal, BCD)通常采用四位二进制数来表示一位十进制数中的0~9这十个数码。这种编码方式使二进制数和十进制数之间的转换得以快速进行。但是四位二进制数可以组合16种代码，因此有6种状态为冗余状态

#### 8421码

> 8421码是一种有权码，也是最为常用的编码。

$$
	D = 8b_3 + 4b_2 + 2b_1 + 1b_0
$$
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 |

- 如果两个8421码相加之和小于等于$(1001)_2$即$(9)_{10}$，则不需要修正，如果大于则需要修正，**修正方式为直接加上6即可，并向高位进位**

#### 余3码

> 余3码是一种无权码，其有8421码的基础上加上$(0011)_2$得来的

$$
	D_{余3码} = D_{8421} + 0011_2
$$

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 | 1010 | 1011 | 1100 |

#### 2421码

> 2421码是一种有权码，其特点是**大于等于5的四位二进制种最高位是1，小于5的最高位是0**

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 0000 | 0001 | 0010 | 0011 | 0100 | 1011 | 1100 | 1101 | 1110 | 1111 |

### 定点整数

> 数据的存储在计算机中使用原反补码的形式来存储
> 正数的原反补码是一致的
> 负数的反码是除符号位以外的位全部取反
> 负数的补码是反码加一

- 原反补码的书面表示

$$
\begin{aligned}
	\left[x\right]_{原} = \underbrace{1}\limits_{符号位},\underbrace{0011}\limits_{数据位} \\
	\left[x\right]_{反} = \underbrace{1}\limits_{符号位},\underbrace{1100}\limits_{数据位} \\
	\left[x\right]_{补} = \underbrace{1}\limits_{符号位},\underbrace{1101}\limits_{数据位}
\end{aligned}
$$

- 可以看见，在书面表示中，**可以使用逗号将数据位的数据分割开来**，如果在位数没有要求的情况下，甚至可以将无效位数省略$\left[x\right]_{原} = \underbrace{1}\limits_{符号位},\underbrace{11}\limits_{数据位}$

#### 原补的定义

- 纯小数的原码定义

$$
\left[x\right]_{原}=\left\{\begin{array}{}
	x & 1 \gt x \ge 0 \\
	1 - x = 1 + |x| & 0 \ge x \gt -1
\end{array}\right. \tag{[x]是原码机器数，x是真值} 
$$

- 纯整数的原码定义

$$
\left[x\right]_{原}=\left\{\begin{array}{}
	0,x & 2^n \gt x \ge 0 \\
	2^n - x = 2^n + |x| & 0 \ge x \gt -2^n
\end{array}\right. \tag{x+是真值，n是整数位数} 
$$

- 纯小数的补码定义

$$
\left[x\right]_{补}=\left\{\begin{array}{}
	x & 1 \gt x \ge 0 \\
	2 + x = 2 - x & 0 \gt x \ge -1
\end{array}\right. \tag{mod 2} 
$$

- 纯整数的补码定义

$$
\left[x\right]_{补}=\left\{\begin{array}{}
	0,x & 2^n \gt x \gt 0 \\
	2^{n+1} + x = 2^{n+1} - |x| & 0 \ge x \ge -2^n
\end{array}\right. 
$$

#### 原码与补码的另一种方式

> 我们知道，补码是原码取反后加一得到的，但是从补码回到原码往往是头疼的事情，因此，有另一种方法可以简单的从补码变为原码

- **补码从右往左数的第一位“1”的左边(除符号位以外)取反即可得到原码，原码也是如此**

$$
\begin{aligned}
	\left[x\right]_{原} = 1, 001001\underline{1} \rightarrow \left[x\right]_{补} = 1,\underline{110110}1 \\
	\left[x\right]_{原} = 1, \underline{001001}1 \leftarrow \left[x\right]_{补} = 1,110110\underline{1}
\end{aligned}
$$

- **补码的数值位不能解读为“位权”**

#### 补码的相反数的另一种方式

> 很多时候，我们也会遇见正数和负数的减法，那么对于负数，我们是先要求取补码，但是求取两次过于麻烦了，那么就有一种新的方式

$$
	\left[x\right]_{补} \mathop{\longleftrightarrow}\limits^{全部位按位取反、末位加一} \left[-x\right]_{补}
$$

- Eg.

$$
\begin{aligned}
	x = 19 \quad \left[x\right]_{补} = 0,0010011 \mathop{\longrightarrow}\limits^{全部位}_{按位取反} 1,1101100 \mathop{\longrightarrow}\limits^{末位+1} 1,1101101 \\
	-x = -19 \quad \left[x\right]_{补} = 1,1101101 \mathop{\longrightarrow}\limits^{全部位}_{按位取反} 0,0010010 \mathop{\longrightarrow}\limits^{末位+1} 0,0010011
\end{aligned}
$$

#### 移码

> 移码常用来表示浮点数的阶码。**其只能表示整数**

- 移码就是在真值X上加上一个常数(偏置值)，通常这个常数取$2^n$，相当于X在数轴上向正方向偏移了若干单位。

$$
	\left[x\right]_{移} = 2^n + x(2^n \gt x \ge -2^n，其中机器字长位n + 1)
$$
- 移码的特点：
	- **移码中零的表示唯一**，$\left[+0\right]_{移} = 2^n + 0 = \left[-0\right]_{移} = 2^n - 0 = 100...0(n个0)$
	- **一个真值的移码和补码仅差一个符号位，也就是说，补码的符号位取反就是移码**
	- 移码保持了数据原有的大小顺序，移码大真值就大

| 真值(十进制) | 补码 | 移码 |
| :---: | :---: | :---: |
| -128 | 1000 0000 | 0000 0000 |
| -127 | 1000 0001 | 0000 0001 |
| -126 | 1000 0010 | 0000 0010 |
| ... | ... | ... |
| -2 | 1111 1110 | 0111 1110 |
| -1 | 1111 1111 | 0111 1111 |
| 0 | 0000 0000 | 1000 0000 |
| 1 | 0000 0001 | 1000 0001 |
| 2 | 0000 0010 | 1000 0010 |
| ... | ... | ... |
| 126 | 0111 1110 | 1111 1110 |
| 127 | 0111 1111 | 1111 1111 |

#### 基本特性总结

| n+1 bit | 合法表示范围 | 最大的数 | 最小的数 | 真值0的表示 |
| :---: | :---: | :---: | :---: | :---: |
| 带符号整数：原码 | $-(2^n-1) \le x \le 2^n-1$ | $0,111...111 = 2^n-1$ | $1,111...111 = -(2^n-1)$ | $\begin{aligned}\left[+0\right]_{原} = 0,000...000\\ \left[-0\right]_{原} = 1,000...000\end{aligned}$ |
| 带符号整数：反码 | $-(2^n-1) \le x \le 2^n-1$ | $0,111...111 = 2^n-1$ | $1,000...000 = -(2^n-1)$ | $\begin{aligned}\left[+0\right]_{反} = 0,000...000\\ \left[-0\right]_{反} = 1,111...111\end{aligned}$ |
| 带符号整数：补码 | $-2^n \le x \le 2^n-1$ | $0,111...111 = 2^n-1$ | $1,000...000 = -2^n$ | $\begin{aligned}\left[0\right]_{补} = 0,000...000\\ 真值0只有一种补码\end{aligned}$ |
| 带符号整数：移码 | $-2^n \le x \le 2^n-1$ | $1,111...111 = 2^n-1$ | $0,000...000 = -2^n$ | $\begin{aligned}\left[0\right]_{移} = 1,000...000\\ 真值0只有一种补码\end{aligned}$ |
| 无符号整数 | $0 \le x \le 2^{n+1}-1$ | $1,111...111 = 2^{n+1}-1$ | $0000...000 = 0$ | $0000...000$ |

- 原反补移总结：
	- 原反补的符号位相同，正数的机器码相同
	- 原反码的表示在数轴上对称，**二者都存在+0和-0**
	- 补码、移码的表示在数轴上不对称，**零表示唯一**
	- 整数的补码、移码的符号位相反，数值位相同
	- 负数的反码、补码末位相差一
	- **对于负数，数值部分越大，绝对值越小，真值越大(越靠近0)**

| 行数 | 机器数 | 无符号数 | 原码 | 反码 | 补码 | 移码 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | 
| 1 | 0000 0000 | 0 | +0 | +0 | +0、-0 | -128 |
| 2 | 0000 0001 | 1 | +1 | +1 | +1 | -127 |
| ... | ... | ... | ... | ... | ... | ... |
| 126 | 0111 1101 | 125 | +125 | +125 | +125 | -3 |
| 127 | 0111 1110 | 126 | +126 | +126 | +126 | -2 |
| 128 | 0111 1111 | 127 | +127 | +127 | +127 | -1 |
| 129 | 1000 0000 | 128 | -0 | -127 | -128 | 0 |
| 130 | 1000 0001 | 129 | -1 | -126 | -127 | 1 |
| 131 | 1000 0010 | 130 | -2 | -125 | -126 | 2 |
| ... | ... | ... | ... | ... | ... | ... | ... |
| 255 | 1111 1110 | 254 | -126 | -1 | -2 | 126 |
| 256 | 1111 1111 | 255 | -127 | -0 | -1 | 127 |

### 定点小数

> 定点小数和定点整数一样，只是定点小数的小数点，固定在符号位之后

| n+1 bit | 合法表示范围 | 最大的数 | 最小的数 | 真值0的表示 |
| :---: | :---: | :---: | :---: | :---: |
| 定点小数：原码 | $-(1 - 2^n) \le x \le 1 - 2^n$ | $0,111...111 = 1 - 2^n$ | $1,111...111 = -(1 - 2^n)$ | $\begin{aligned}\left[+0\right]_{原} = 0,000...000\\ \left[-0\right]_{原} = 1,000...000\end{aligned}$ |
| 定点小数：反码 | $-(1 - 2^n) \le x \le 1 - 2^n$ | $0,111...111 = 1 - 2^n$ | $1,000...000 = -(1 - 2^n)$ | $\begin{aligned}\left[+0\right]_{反} = 0,000...000\\ \left[-0\right]_{反} = 1,111...111\end{aligned}$ |
| 定点小数：补码 | $-1 \le x \le 1 - 2^n$ | $0,111...111 = 1 - 2^n$ | $1,000...000 = -1$ | $\begin{aligned}\left[0\right]_{补} = 0,000...000\\ 真值0只有一种补码\end{aligned}$ |

### 奇偶校验码

> 奇偶校验用于检测数据传输过程中是否发生错误

#### 检验原理

- 在原位数上，增加一位用于检验，则就有$2^{n-1}$个冗余的非法状态

#### 奇偶校验码

> 整个校验码中“1”的个数为奇数则是奇校验码
> 整个校验码中“1”的个数为偶数则是偶校验码

![[奇偶校验.png]]

- 如果想要求出数码对应的奇偶校验，那么直接进行增加对应即可

##### 偶校验的硬件实现

- 各信息进行异或(模2加)运算，得到的结果即为偶校验位

$$
\begin{aligned}
	x_1 = 1 \bigoplus 0 \bigoplus 0 \bigoplus 1 \bigoplus 1 \bigoplus 0 \bigoplus 1 = 0 \\
	x_2 = 1 \bigoplus 0 \bigoplus 1 \bigoplus 0 \bigoplus 1 \bigoplus 1 \bigoplus 1 = 1
\end{aligned}
$$
> 可以见看，编码$1001101$的偶校验位$x_1 = 0$,则其偶校验码为$01001101$
> 编码$1010111$的偶校验位$x_2 = 1$,则其偶校验码为$11010111$

### 运算方法和运算电路

#### 一位全加器

> 全加器(FA)是最基本的加法单元，有加数$A_i$和加数$B_i$与低位传来的进位$C_{i-1}$共三个输入，有本位和$S_i$与向高位进位的$C_i$两个输出

![[全加器.png]]

- 全加器的逻辑表达式为：

$$
\begin{aligned}
	S_i &= A_i \bigoplus B_i \bigoplus C_{i-1} \\
	C_i &= A_iB_i + (A_i \bigoplus B_i)C_{i-1}
\end{aligned}
$$

![[全加器逻辑电路.png]]

##### 串行加法器

> 只有一个全加器，数据逐位串行送入加法器中进行运算，进位触发器用来存储进位信号，以便参加下一次运算

![[串行全加器.png]]

- 如果操作数长n位，加法就要分n次进行，每次产生一位和，并且串行逐位地送回寄存器

##### 串行进位加法器

> 串行进位加法器：把n个全加器串接起来，就可以进行两个n位数的相加。**串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，即进位信号是逐级形成的**

$$
\begin{aligned}
	A &= A_nA_{n-1}...A_1 \qquad B = B_nB_{n-1}...B_1 \\
	S &= S_nb_{n-1}...S_1 \qquad C = C_n
\end{aligned}
$$

![[串行进位全加器.png]]

- 串行进位加法器中，低位运算产生进位所需的时间将影响高位运算的时间。因此，**串行进位加法器的最长运算时间主要是由进位信号的传递时间决定的，位数越多延迟时间就越长，且全加器本身求和延迟很低，所以加快进位产生和提高传递的效率才是关键**

##### 并行加法器

> 我们通过串行进位加法器知道，位数越多，进位延迟越高，因此，并行加法器就是为了解决传递延迟问题

- 当我们对串行进位加法器的逻辑表达式进行分析：

$$
\begin{aligned}
	C_i &= A_iB_i + (A_i \bigoplus B_i)C_{i-1} \\
	C_i &= A_iB_i + (A_i \bigoplus B_i)(A_{i-1}B_{i-1} + (A_{i-1} \bigoplus B_{i-1})C_{i-2}) \\
	&..... \\
	Ci &= A_iB_i + (A_i \bigoplus B_i)(A_{i-1}B_{i-1} + (A_{i-1} \bigoplus B_{i-1})...C0)
\end{aligned}
$$
- 可以发现，第$i$位向更高位的进位$C_i$可根据被加数、加数的第$1~i$位再结合$C_0$确定
- 那么此时，我们约定$G_i = A_iB_i \qquad P_i = A_i \bigoplus B_i$

$$
\begin{aligned}
	C_i &= A_iB_i + (A_i \bigoplus B_i)C_{i-1} = G_i + P_iC_{i-1} \\
	\\
	C_1 &= G_1 + P_1C_0 \\
	C_2 &= G_2 + P_2C_1 = G_2 + P_2G_1 + P_2P_1C_0 \\
	C_3 &= G_3 + P_3C_2 = G_3 + P_3P_2G_1 + P_3P_2P_1C_0 \\
	&.... \\
	C_i &= G_i + P_iC_{i-1} = G_i + P_iP_{i-1}...P_2G_1 + P_iP_{i-1}...P_1C_0
\end{aligned}
$$
- 我们将$G_i = A_iB_i$称为进位产生函数(本地函数)
- 将$P_i = A_i \bigoplus B_i$称为进位传递函数(进位传递条件)，可以看出，$C_i$仅与$A_i \ B_i$以及最低进位$C_0$有关，互相之间的进位没有依赖关系。
- 实现上述逻辑表达式的电路被称为先行进位(也称超前进位)部件，简称CLA部件，而依据这种进位方法实现的加法器被称为全先行进位加法器

![[全先行进位加法器.png]]

- 虽然这种进位方式是快速的，与位数就没了关系，但是随着加法器位数的增加，$C_i$的逻辑表达式会变得异常复杂，**所以，位数多的时候采用全先行进位是不现实的**
- 因此，**我们可以通过多个CLA部件串行进位，组内采用先行进位的方式，就能够使得综合考虑上最为合适的方式，采用两级或多级先行进位加法器**

#### 算数逻辑单元ALU

> ALU是一种功能较强的组合逻辑电路，能够进行多种算术运算和逻辑运算。**由于加减乘除运算最终都能归结为加法运算，因此ALU的核心是带标志加法器**

![[ALU.png]]

- A、B是两个n位操作数输入端
- $C_{in}$是进位输入端，$C_{out}$是最高位进位输出端
- $ALU_{op}$是选择功能执行，可选项有加减乘除等算数运算和与或非等逻辑运算，**$ALU_{op}$的位数决定了操作的种类**

##### 加法器原理

> 加法器内部是一系列的全先行进位加法器

![[加法器.png]]

- 可以看见的是，加法器有
	- 两个加数输入端和一个低位进位输入端
	- 一个结果输出端和一个最高位进位输出端

$$
Eg.
\begin{aligned}
	A = 1000, B = 0111, C_{in} = 0 \Rightarrow F = 1111, C_{out} = 0 \\
	A = 1000, B = 0111, C_{in} = 1 \Rightarrow F = 0000, C_{out} = 1
\end{aligned}
$$

- 但是，我们发现，**这种加法器，只能针对原码进行计算，如果涉及到补码，就无法进行有效计算**

##### 补码加法器运算

> 在之前我们已经了解了$-\left[x\right]_{补} = \left[-x\right]_{补}$，并且对于补码的计算，计算机通常是利用加法计算

![[补码加法器.png]]

- 可以看见，我们在加数上增加一个多路选择器MUX，该选择器会判断，补码的正负从而进行相应操作
	- 如果是正数，那么就不需要进行额外操作直接进行加法
	- 如果是负数，那么就将该补码全部取反后，向$C_{in}$送上高电平表示末位加一，然后进行加法

- Eg. 4bit补码，$X = -8， Y = 7, X_{补} = 1000， Y_{补} = 0111$
$$
\begin{aligned}
	X + Y &= X_{补} + Y_{补} = 1111B = -1D \\
	X - Y &= X_{补} + (-Y_{补}) \\ 
		  &= 1000B + (1000 + 1)B \\ 
		  &= \mathop{\underline{1}}\limits_{舍去}0001 = 1D
\end{aligned}
$$

- 但是，**如果我们使用无符号整数进行计算，那么结果又不符合预期**。就比如，示例中$X = 3, Y = 4, X - Y = 15D$，这显然是不正常的。
- 因此我们引入了，标志位

##### 标志位生成

> 为了让加法器能够在一套电路上同时实现无符号和有符号的计算，因此在加法器上增加了相应的逻辑门电路

![[带标志位加法器.png]]
- 注：此处为了方标，图示上的FA应该使用先行进位方式

| 标志位 | 含义 | 计算方法 | 注意 |
| :---: | :---: | :---: | :---: |
| OF(Overflow Flag) | 有符号的加减运算是否发生了溢出 | $OF = C_n \bigoplus C_{n-1}$(最高位产生的进位异或次高位的进位) | OF位与无符号数的加减法无意义 |
| SF(Sign Flag) | 有符号数加减运算的正负性。$SF = 0$表示正数 | $SF = S_n$(最高位的本位和) | SF位对无符号数的加减法无意义 |
| ZF(Zero Flag) | 表示运算结果是否位0。$ZF = 1$表示结果为0 | 两个数的运算结果为$nbit$，当$nbit$全为0时，$ZF = 1$ |  |
| CF(Carry Flag) | 进位/借位标志，表示无符号数的加减法是否发生了进位或借位。$CF = 1$说明发生了 | $CF = C_n \bigoplus sub$(最高位进位异或sub) | CF位对有符号数的加减法无意义 |

- 通过这样，就能够完成一个通用的加法器了

### 定点数的位移运算

#### 算术移位

> 算术移位的对象是有符号数，在移位过程中符号位保持不变

- 对于正数，由于$\left[x\right]_{原} = \left[x\right]_{反} = \left[x\right]_{补} = 真值$，**因此移位后出现的空位均以0添之**。对于负数，由于原反补的表示形式不同，因此得单独计算规则
- **不论是正数还是负数，算术移位后其符号位均不变，且移位后都相当于对真值补0**

- 对于负数的反码来说，其移位后填1
- 对于负数的补码来说，找到从右至左的第一位1，然后作为分界线，右边的添0，左边添1

$$
	\left[x\right]_{补} = 1,\underbrace{1101}\limits_{同反码规则}\underbrace{100}\limits_{同原码规则}
$$
- 不同机器数算数移位后的空位填补规则

|  | 码制 | 填补代码 |
| :---: | :---: | :---: |
| 正数 | 原码、反码、补码 | 0 |
| 负数 | 原码 | 0 |
| 负数 | 反码 | 1 |
| 负数 | 补码 | 左移填0、右移填1 |

#### 逻辑移位

> 逻辑移位将操作数视为无符号数

- 位移规则：**逻辑左移，高位移丢，低位填0; 逻辑右移，低位移丢，高位填0**

#### 循环移位

> 循环移位分为带标志位CF的循环移位(大循环)和不带标志位的循环移位(小循环)

![[循环移位.png]]

- 其符号位参与移位
- **循环移位操作特别适合将数据的低字节数据和高字节数据互换**

### 定点数的乘除运算

> 在开始之前，我们需要了解一个东西：溢出判别方法，其常用于补码

#### 溢出判别方法

> 仅当两个符号相同的数相加或两个符号相异的数相减才可能产生溢出

##### 采用一位符号位

> 由于减法运算在机器中使用加法器实现的，**因此无论是加法还是减法，只要参加操作的两个数符号相同，结果又与原操作数符号不同，则结果溢出**

- 设A的符号为$A_s$，B的符号为$B_s$，运算结果的符号为$S_s$，则溢出表达式为

$$
	V = A_sB_s\overline{S_s} + \overline{A_sB_s}S_s
$$
- 若$V = 0$，则表示无溢出

##### 采用双符号位

> 双符号位也称模4补码。**运算结果的两个符号位$S_{s1}S_{s2}$相同。表示未溢出，且最高位符号位代表真正的符号**

- 溢出表达式为

$$
	V = S_{s1} \bigoplus S_{s2}
$$
- 比如$S_{s1}S_{s2} = 00$，表示结果为正数，且无溢出
- $S_{s1}S_{s2} = 10$，表示结果为负溢出

##### 采用一位符号位根据进位情况判断

> 若符号位的进位$C_s$与最高数位的进位$C_1$相同，则说明没有溢出。

- 溢出表达式为

$$
	V = C_{n} \bigoplus C_1
$$
- 若$V = 0$，则说明无溢出