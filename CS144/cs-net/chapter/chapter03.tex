\chapter{运输层}

    运输层位于应用层和网络层之间，是分层的网络体系结构的重要部分。该层为运行在不同主机上的应用进程提供直接的通信服务起着至关重要的作用。

\section{概述和运输层服务}

    运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信(logic communication)功能。从应用程序的角度看，通过逻辑通信，运行不同进程的主机好像直接相连一样；

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.6\textwidth]{image/chapter03/运输层.png}
    \caption{运输层在应用程序进程间提供逻辑的并非物理的通信}
\end{figure}

    如上图所示，运输层协议是在端系统中而不是在路由器中实现的。在发送端，运输层将从发送应用程序进程接收到的报文转换成运输层分组，用因特网术语来讲该分组称为运输层报文段(segment)。

    实现的方法(可能)是将应用报文划分为较小的块，并为每块加上一个运输层首部以生成运输层报文段。然后，在发送端系统中，运输层将这些报文段传递给网络层，网路层将其封装成网络层分组(即数据报)并向目的地发送。

\subsection{运输层和网络层的关系}

    网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信。

    运输层协议只工作在端系统中。在端系统中，运输层协议将来自应用进程的报文移动到网络边缘(即网络层)，反过来也是一样，但对有关这些报文在网络核心如何移动并不作任何规定。

    运输协议能够提供的服务常常受制于底层网络层协议的服务模型。如果网络层协议无法为主机之间发送的运输层报文段提供时延或带宽保证的话，运输层协议也就无法为进程之间发送的应用程序报文提供时延或带宽保证。

\subsection{因特网运输层概述}

    因特网为应用层提供了两种截然不同的可用运输层协议。这些协议一种是UDP(用户数据报协议)，它为调用它的应用程序提供了一种不可靠、无连接的服务。另一种是TCP(传输控制协议)，它为调用它的应用程序提供了一种可靠的、面向连接的服务。

    为了简化术语，我们将运输层分组称为报文段(segment)。然而，\emph{因特网文献(如RFC文档)也将TCP的运输层分组称为报文段，而常将UDP的分组称为数据报(data gram)。而这类因特网文献也将网络层分组称为数据报！}在此处，我们将TCP和UDP的分组统称为报文段。

    因特网网络层协议有一个名字叫IP,即网际协议。IP为主机之间提供了逻辑通信。IP的服务模型是尽力而为交付服务(best-effort delivery service)。

    这意味着IP尽它“最大的努力”在通信的主机之间交付报文段，但它并不做任何确保。特别是，它不确保报文段的交付，不保证报文段的按序交付，不保证报文段中数据的完整性。由于这些原因，IP被称为不可靠服务(unreliable service)。在此处，我们只需要记住每台主机只有一个IP地址。

    UDP和TCP最基本的责任是，将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。将主机间交付扩展到进程间交付被称为运输层的多路复用(transport-layer multiplexing)与多路分解(demultiplexing)。

    UDP和TCP还可以通过在其报文段首部中包括差错检查字段而提供完整性检查。进程到进程的数据交付和差错检查是两种最低限度的运输层服务，也是UDP所能提供的仅有的两种服务。特别是，与IP—样，UDP也是一种不可靠的服务，即不能保证一个进程所发送的数据能够完整无缺地(或全部！)到达目的进程。

\section{多路复用与多路分解}

    \emph{多路复用与多路分解服务是所有计算机网络都需要的}。

    在目的主机，运输层从紧邻其下的网络层接收报文段。运输层负责将这些报文段中的数据交付给在主机上运行的适当应用程序进程。

    一个进程(作为网络应用的一部分)有一个或多个套接字(socket),它相当于从网络向进程传递数据和从进程向网络传递数据的门户。因此，如下所示，在接收主机中的运输层实际上并没有直接将数据交付给进程，而是将数据交给了一个中间的套接字。由于在任一时刻，在接收主机上可能有不止一个套接字，所以每个套接字都有唯一的标识符。

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.6\textwidth]{image/chapter03/多路复用和多路分解.png}
    \caption{运输层的多路复用与多路分解}
\end{figure}

    现在我们考虑接收主机怎样将一个到达的运输层报文段定向到适当的套接字。为此目的，每个运输层报文段中具有几个字段。在接收端，运输层检查这些字段，标识出接收套接字，进而将报文段定向到该套接字。

    \emph{将运输层报文段中的数据交付到正确的套接字}的工作称为多路分解(demultiplexing)。

    \emph{在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息(这将在以后用于分解)从而生成报文段，然后将报文段传递到网络层，所有这些工作}称为多路复用(multiplexing)。

    运输层多路复用要求:

\begin{itemize}
    \item [1)] 套接字有唯一标识符
    \item [2)] 每个报文段有特殊字段来指示该报文段所要交付到的套接字
\end{itemize}

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.4\textwidth]{image/chapter03/运输层报文段中的源-目的端口号字段.png}
    \caption{运输层报文段中源与目的端口字段}
\end{figure}

    这些特殊字段是源端口号字段(source port number field)和目的端口号字段(destination port number field)。

    端口号是一个16比特的数，其大小在0 ~ 65535之间。0 ~ 1023范围的端口号称为周知端口号(well-known port number),是受限制的。

    现在应该清楚运输层是怎样能够实现分解服务的了：在主机上的每个套接字能够分配一个端口号，当报文段到达主机时，运输层检査报文段中的目的端口号，并将其定向到相应的套接字。然后报文段中的数据通过套接字进入其所连接的进程。

\subsubsection{无连接的多路复用与多路分解}

    \emph{一个UDP套接字是由一个二元组全面标识的，该二元组包含一个目的IP地址和一个目的端口号。因此，如果两个UDP报文段有不同的源IP地址和/或源端口号，但具有相同的目的IP地址和目的端口号，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程}

\subsubsection{面向连接的多路复用和多路分解}

    \emph{TCP套接字是由一个四元组(源IP地址, 源端口号，目的IP地址，目的端口号)来标识的。因此，当一个TCP报文段从网络到达一台主机时，该主机使用全部4个值来将报文段定向（分解）到相应的套接字。特别与UDP不同的是，两个具有不同源IP地址或源端口号的到达TCP报文段将被定向到两个不同的套接字，除非TCP报文段携带了初始创建连接的请求}。

\section{无连接运输：UDP}

    由［RFC 768］定义的UDP只是做了运输协议能够做的最少工作。除了复用/分解功 能及少量的差错检测外，它几乎没有对IP增加别的东西。

    有许多应用更适合用UDP,原因主要以下几点：

\begin{itemize}
    \item [1)] 关于发送什么数据以及何时发送的应用层控制更为精细。
    \subitem 采用UDP时，只要应用进程将数据传递给UDP, UDP就会将此数据打包进UDP报文段并立即将其传递给网络层。
    \item [2)] 无须连接建立。
    \subitem UDP不会引入建立连接的时延。这可能是DNS运行在UDP之上而不是运行在TCP之上的主要原因。
    \item [3)] 无连接状态。
    \subitem TCP需要在端系统中维护连接状态。此连接状态包括接收和发送缓存、拥塞控制参数以及序号与确认号的参数。UDP不维护连接状态，也不跟踪这些参数。
    \item [4)] 分组首部开销小。
    \subitem 每个TCP报文段都有20字节的首部开销，而UDP仅有8字节的开销。
\end{itemize}

\subsection{UDP报文段结构}

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.4\textwidth]{image/chapter03/UDP报文段结构.png}
    \caption{UDP报文段结构}
\end{figure}

    UDP首部只有4个字段，每个字段由两个字节组成。通过端口号可以使目的主机将应用数据交给运行在目的端系统中的相应进程(即执行分解功能)。长度字段指示了在UDP报文段中的字节数(首部加数据)。因为数据字段的长度在一个UDP段中不同于在另一个段中，故需要一个明确的长度。接收方使用检验和来检查在该报文段中是否出现了差错。

\subsection{UDP校验和}

    UDP检验和提供了差错检测功能。这就是说，检验和用于确定当UDP报文段从源到达目的地移动时，其中的比特是否发生了改变。

    发送方的UDP对报文段中的所有16比特字的和进行反码运算, 求和时遇到的任何溢出都被回卷。得到的结果被放在UDP报文段中的检验和字段。

    在既无法确保逐链路的可靠性，又无法确保内存中的差错检测的情况下，如果端到端数据传输服务要提供差错检测，UDP就必须在端到端基础上在运输层提供差错检测。这是一个在系统设计中被称颂的端到端原则(end-encl principle)的例子。

\section{可靠数据传输原理}

    下图说明了我们的学习框架。为上层实体提供的服务抽象是：数据可以通过一条可靠的信道进行传输。借助于可靠信道，传输数据比特就不会受到损坏(由0变为1,或者相反)或丢失，而且所有数据都是按照其发送顺序进行交付。这恰好就是TCP向调用它的因特网应用所提供的服务模型。

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.6\textwidth]{image/chapter03/可靠数据传输.png}
    \caption{可靠数据传输：服务模型与服务实现}
\end{figure}

    实现这种服务抽象是可靠数据传输协议(reliable data transfer protocol)的责任。由于可靠数据传输协议的下层协议也许是不可靠的，因此这是一项困难的任务。

\subsection{构造可靠数据传输协议}

\subsubsection{经完全可靠信道的可靠数据传输：rdt1.0}

    首先，我们考虑最简单的情况，即底层信道是完全可靠的。我们称该协议为rdt1.0,该协议本身是简单的。

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.6\textwidth]{image/chapter03/rdt1.0-用于完全可信的数据传输.png}
    \caption{rdt1.0：用于完全可靠信道的协议}
\end{figure}

    上图显示了rdt1.0发送方和接收方的有限状态机(Finite-State Machine, FSM)的定义。

    发送方和接收方有各自的FSM。上图中发送方和接收方的FSM每个都只有一个状态。FSM描述图中的箭头指示了协议从一个状态变迁到另一个状态(因为每个FSM都只有一个状态，因此变迁必定是从一个状态返回到自身；我们很快将看到更复杂的状态图)。

    引起变迁的事件显示在表示变迁的横线上方，事件发生时所采取的动作显示在横线下方。如果对一个事件没有动作，或没有事件发生而采取了一个动作，我们将横线上方或下方使用符号$\land$，以分别明确地表示缺少动作或事件。FSM初始状态用虚线表示。

\subsubsection{经具有比特差错信道的可靠数据传输：rdt2.0}

    底层信道更为实际的模型是分组中的比特可能受损的模型。在分组的传输、传播或缓存的过程中，这种比特差错通常会岀现在网络的物理部件中。

    在研发一种经这种信道进行可靠通信的协议之前，首先考虑一下人们会怎样处理这类情形。种口述报文协议使用了肯定确认(positive acknowledgment)("OK”)与否定确认(negative acknowledgmenl)("请重复一遍)。这些控制报文使得接收方可以让发送方知道哪些内容被正确接收，哪些内容接收有误并因此需要重复。在计算机网络环境中，基于这样重传机制的可靠数据传输协议称为自动重传请求 (Automatic Repeat reQuest, ARQ)协议。

    ARQ协议中需要另外三种协议来处理存在比特差错的情况：

\begin{itemize}
    \item [1)] 差错检测。
    \subitem 首先，需要一种机制以使接收方检测到何时出现了比特差错。前一节讲到，UDP使用因特网检验和字段正是为了这个目的。
    \item [2)] 接收方反馈。
    \subitem 因为发送方和接收方通常在不同端系统上执行，可能相隔数千英里, 发送方要了解接收方情况(此时为分组是否被正确接收)的唯一途径就是让接收方提供明确的反馈信息给发送方。我们的rdt2.0协议将从接收方向发送方回送ACK与NAK分组。理论上，这些分组只需要一个比特长; 如用0表示NAK,用1表示ACK。
    \item [3)] 重传。
    \subitem 接收方收到有差错的分组时，发送方将重传该分组文。
\end{itemize}

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.6\textwidth]{image/chapter03/rdt2.0-具有比特差错的机制.png}
    \caption{rdt2.0：用于具有比特差错信道的协议}
\end{figure}

    下图表示rdt2.0的FSM，该数据协议采用了差错检测、肯定确认与否定确认。

    rdt2.0的发送端有两个状态。在最左边的状态中，发送端协议正等待来自上层传下来的数据。当$rdt\_send(data)$事件岀现时，发送方将产生一个包含待发送数据的分组(sndpkt),带有检验和，然后经由$udt\_send(sndpkt)$操作发送该分组。

    在最右边的状态中，发送方协议等待来自接收方的ACK或NAK分组。如果收到一个ACK分组(图中符号$rdt\_rcv(rcvpkt) \&\& isACK(rcvpkt)$对应该事件)，则发送方知道最近发送的分组已被正确接收，因此协议返回到等待来自上层的数据的状态。如果收到一个NAK分组，该协议重传上一个分组并等待接收方为响应重传分组而回送的ACK和NAK。

    \emph{当发送方处于等待ACK或NAK的状态时，它不能从上层获得更多的数据；这就是说，rdcsend()事件不可能岀现；仅当接收到ACK并离开该状态时才能发生这样的事件。因此，发送方将不会发送一块新数据，除非发送方确信接收方已正确接收当前分组}。由于这种行为，rdt2.0这样的协议被称为停等(stop and-wait)协议

    rdt2.0协议看起来似乎可以运行了，但遗憾的是，它存在一个致命的缺陷。尤其是我们没有考虑到ACK或NAK分组受损的可能性!

    考虑处理ACK和NAK时的三种可能性：

\begin{itemize}
    \item [1)] 第一种可能性，接收者不明白发起者的话是口述内容的一部分还是一个要求重复上次回答的请求
    \item [2)] 第二种可能性，增加足够的检验和比特，使发送方不仅可以检测差错，还可恢复差错。对于会产生差错但不丢失分组的信道，这就可以直接解决问题
    \item [3)] 第三种方法是，当发送方收到含糊不清的ACK或NAK分组时，只需重传当前数据分组即可。
    \subitem 这种方法在发送方到接收方的信道中引入了冗余分组(duplicate packet)。冗余分组的根本困难在于接收方不知道它上次所发送的ACK或NAK是否被发送方正确地收到。因此它无法事先知道接收到的分组是新的还是一次重传!
\end{itemize}

    解决这个新问题的一个简单方法(几乎所有现有的数据传输协议中，包括TCP,都采用了这种方法)是在数据分组中添加一新字段，让发送方对其数据分组编号，即将发送数据分组的序号(sequence number)放在该字段。

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.6\textwidth]{image/chapter03/rdt2.1发送方.png}
    \caption{rdt2.1 发送方}
\end{figure}

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.6\textwidth]{image/chapter03/rdt2.1接收方.png}
    \caption{rdt2.1 接收方}
\end{figure}

    剩下的rdt2.2，rdt3.0后面再说吧。。不想看了

\section{面向连接的运输：TCP}

\subsection{TCP连接}

    TCP被称为是面向连接的(connection-oriented),这是因为在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须先相互“握手”，即它们必须相互发送某些预备报文段，以建立确保数据传输的参数。作为TCP连接建立的一部分，连接的双方都将初始化与TCP连接相关的许多TCP状态变量

    TCP连接也总是点对点(point-to-point)的，即在单个发送方与单个接收方之间的连接。所谓“多播”（参见本书的在线补充材料），即在一次发送操作中，从一个发送方将数据传送给多个接收方，这种情况对TCP来说是不可能的。

    一旦建立起一条TCP连接，两个应用进程之间就可以相互发送数据了。客户进程通过套接字(该进程之门)传递数据流。数据一旦通过该门，它就由客户中运行的TCP控制了。

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.6\textwidth]{image/chapter03/TCP发送缓存和接收缓存.png}
    \caption{TCP发送缓存和接收缓存}
\end{figure}

    TCP将这些数据引导到该连接的发送缓存(send buffer)里，发送缓存是发起三次握手期间设置的缓存之一。接下来TCP就会不时从发送缓存里取出一块数据，并将数据传递到网络层。

    TCP可从缓存中取出并放入报文段中的数据数量受限于最大报文段长度(Maximum Segment Size,MSS)。MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度(即所谓的最大传输单元(Maximum Transmission Unit, MTU))来设置。

    设置该MSS要保证一个TCP报文段(当封装在一个IP数据报中)加上TCP/IP首部长度(通常40字节)将适合单个链路层帧。以太网和PPP链路层协议都具有1500字节的MTU,因此MSS的典型值为1460字节。已经提出了多种发现路径MTU的方法，并基于路径MTU值设置MSS(路径MTU是指能在从源到目的地的所有链路上发送的最大链路层帧[RFC 1191])。注意到MSS是指在报文段里应用层数据的最大长度，而不是指包括首部的TCP报文段的最大长度。

\subsection{TCP报文结构}

    TCP报文段由首部字段和一个数据字段组成。数据字段包含一块应用数据。如前所述，MSS限制了报文段数据字段的最大长度。当TCP发送一个大文件，例如某Web页面上的一个图像时，TCP通常是将该文件划分成长度为MSS的若干块(最后一块除外，它通常小于MSS)。

    下图显示了TCP报文段的结构：

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.6\textwidth]{image/chapter03/TCP报文结构.png}
    \caption{TCP报文段结构}
\end{figure}

    除了源端口号和目的端口号外，还包括：

\begin{itemize}
    \item [1)] 32比特的序号字段(sequence number field)和32比特的确认号字段(acknowledgment number field)
    \subitem 这些字段被TCP发送方和接收方用来实现可靠数据传输服务
    \item [2)] 16比特的接收窗口字段(receive window field)
    \subitem 该字段用于流量控制。我们很快就会看到，该字段用于指示接收方愿意接受的字节数量。
    \item [3)] 4比特的首部长度字段(header length field)
    \subitem 该字段指示了以32比特的字为单位的TCP首部长度。由于TCP选项字段的原因，TCP首部的长度是可变的。(通常,选项字段为空，所以TCP首部的典型长度是20字节。)
    \item [4)] 可选与变长的选项字段(options field)
    \subitem 该字段用于发送方与接收方协商最大报文段长度(MSS)时，或在高速网络环境下用作窗口调节因子时使用。首部字段中还定义了一个时间戳选项。
    \item [5)] 6比特的标志字段(flag field)
    \subitem [a] ACK比特用于指示确认字段中的值是有效的，即该报文段包括一个对已被成功接收报文段的确认。
    \subitem [b] RST、SYN和FIN比特用于连接建立和拆除
    \subitem [c] 在明确拥塞通告中使用了CWR和ECE比特
    \subitem [d] 当PSH比特被置位时，就指示接收方应立即将数据交给上层
    \subitem [e] URG比特用来指示报文段里存在着被发送端的上层实体置为“紧急”的数据。紧急数据的最后一个字节由16比特的紧急数据指针字段(urgent data pointer field)指出。当紧急数据存在并给出指向紧急数据尾指针的时候，TCP必须通知接收端的上层实体。
\end{itemize}

    \emph{在实践中，PSH、URG和紧急数据指针并没有使用。为了完整性起见，我们才提到这些字段}。

    