\chapter{内存寻址}

\section{内存地址}

    在使用80x86微处理器时，我们必须区分以下三种不同的地址：

\begin{itemize}
    \item 逻辑地址(logical address)
    \subitem 包含在机器语言指令中用来指定一个操作数或一条指令的地址。\emph{每一个逻辑地址都由一个段(segment)和偏移量(offset或displacement)组成，偏移量指明了从段开始的地方到实际地址之间的距离。}
    \item 线性地址(linear address)(也称虚拟地址 virtual address)
    \subitem 是一个32位无符号整数，可以用来表示高达4GB的地址。
    \item 物理地址(physical address)
    \subitem 用于内存芯片级内存单元寻址。从微处理器的地址引脚发送到内存总线上的电信号相对应。
\end{itemize}

    \emph{内存控制单元(MMU)通过分段单元(segmentation unit)的硬件电路把一个逻辑地址转换成线性地址，然后分页单元(paging unit)的硬件电路把线性地址转化为物理地址}。

    在多处理器中，所有CPU都共享同一内存：这意味着RAM可以由独立的CPU并发访问。但因为RAM上的读写必须串行执行，因此需要内存仲裁器(memory arbiter)的硬件电路插在总线和RAM芯片之间。

    内存仲裁器的作用是：\emph{如果某个RAM空闲，就准予CPU访问。若RAM忙于另一个CPU提出的请求服务，就延迟这个CPU的访问}

\section{硬件中的分段}

    从80286模型开始，Intel处理器以实模式\footnote[1]{\emph{实模式（Real Mode）是x86体系结构中的一种工作模式，它是早期x86处理器的默认工作模式。在实模式下，处理器以16位的方式进行操作，可以直接访问1MB的物理内存。在实模式下，内存寻址是通过段地址和偏移地址的组合来实现的。段地址由段寄存器（如CS、DS、ES等）保存，偏移地址由指令中的操作数给出。通过将段地址左移4位后与偏移地址相加，可以计算出实际的物理地址}}(real mode)和保护模式(protected mode)执行地址转换。

\subsection{段选择符和段寄存器}

    一个逻辑地址由\emph{一个段标识符(16位长的字段，段选择符(Segment Selector))和一个指定段内相对地址的偏移量(32位长的字段)组成。}

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{image/chapter02/段选择符格式.png}
    \caption{段选择符格式}
\end{figure}

    为了方便段选择符，段寄存器用于存放段选择符。其拥有六个寄存器：

\begin{table*}[!htbp]
    \begin{center}
        \begin{tabular}{c | c}
            cs & 代码段寄存器，指向包含程序指令的段 \\
            ss & 栈段寄存器，指向包含当前程序栈的段 \\
            ds & 数据段寄存器，指向包含静态数据或者全局数据段 \\
            es, fs, gs & 一般用途，可以指向任意数据段 
        \end{tabular}
    \end{center}
\end{table*}

    cs寄存器：\emph{包含一个两位的字段，用以指明CPU的当前特权级\footnote[1]{\emph{值为0表示最高优先级，值为3为最低。Linux只用0和3表示内核态和用户态。}}(Current Privilege Level， CPL)。}

\subsection{段描述符}

    每个段由一个8字节的段描述符(Segment Descriptor)表示，描述了段的特征。

    段描述符放在全局描述符表(Global Descriptor Table，GDT)或局部描述符表(Local Descriptor Table，LDT)中。

    通常只定义一个GDT，每个进程除了存放在GDT中的段之外如果还需附加，就可以使用LDT。GDT在主存中的地址和大小存放在gdtr控制寄存器中，LDT地址和大小存放在ldtr控制寄存器中。

\begin{table*}[!htbp]
    \begin{center}
        \caption{段描述符字段}
        \begin{tabular}{c l}
            \hline
            \emph{字段名} & \emph{描述} \\
            Base & 包含段的首字节的线性地址 \\ 
            G & 粒度标志；若清零，则段大小以字节为单位，否则以4096字节倍数计 \\
            Limit & 存放段中最后一个内存单元的偏移量，从而决定段的长度。\\
            S & 系统标志；置零表示系统段，否则是普通代码段或数据段 \\
            Type & 描述了段的类型特征和存取权限 \\
            DPL & 描述符特权级(Dsecriptor Privilege Level)字段；用于限制这个段的存取。\\
            & 其表示为访问这个段要求的CPU最小优先级。若DPL设为0的段只能\\
            & 当CPL为0时(即内核态)可访问 \\
            P & Segment-Present标志；等于0表示段当前不在主存中\\ 
            & \emph{Linux总是把这个标志设置为1，因为其从不把整个段交换到磁盘}\\
            D或B & 取决于是代码段还是数据段。D或B的含义在两种情况下略有区别\\
            & 如果偏移量32位则置1，否则清零 \\
            \hline
        \end{tabular}
    \end{center}
\end{table*}

    有几种不同类型的段以及对应的段描述符：

\begin{itemize}
    \item 代码段描述符
    \subitem 表示这个段描述符表示代码段，S标志置1
    \item 数据段描述符
    \subitem 表示这个段描述符表示数据段，S标志置1
    \item 任务状态段描述符(TSSD)
    \subitem 表示这个段描述符表示任务状态段(Task State Segment, TSS)，也就是该段用于保存处理器寄存器的内容。\emph{只能出现在GDT中，根据相应进程是否在CPU上，其Type字段值为11或9，S标志置零}
    \item 局部描述符表描述符(LDTD)
    \subitem 表示这个段描述符包含一个LDT段，其只出现在GDT中。相应的Type字段值为2，S标志置0
\end{itemize}

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{image/chapter02/段描述符格式.png}
    \caption{段描述符格式}
\end{figure}

\subsection{快速访问段描述符}

    \emph{逻辑地址由16位段选择符和32位偏移量组成，段寄存器仅仅存放段选择符。}

    为了加速逻辑地址$\rightarrow$线性地址，80x86处理器提供了附加的非编程的寄存器，供6个可编程的段寄存器使用。每一个非编程的寄存器含有八个字节的段描述符，由对应的段寄存器中的段选择描述符来指定。

    每当一个段选择符被装入段寄存器，相应的段描述符就由内存装入对应的非编程CPU寄存器。这时，针对该段的逻辑地址转换就可以仅访问该非编程寄存器即可(除非段寄存器内容发生更改)。

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{image/chapter02/段选择符和段描述符.png}
    \caption{段选择符和段描述符}
\end{figure}

\begin{table*}[!htbp]
    \begin{center}
        \caption{段选择符字段}
        \begin{tabular}{c l}
            \hline
            \emph{字段名} & \emph{描述} \\
            index & 指定了描述放在GDT/LDT中对应的段描述符入口 \\
            TI & TI((Table Indicator)标志，指明段描述符是在GDT(TI = 0)中或LDT(TI = 1)中) \\
            RPL & 请求者特权级，当相应的段选择符装入到cs寄存器中时指示出CPU当前的特权级 \\
            & 还可以用于访问数据段时选择地削弱特权级 \\
            \hline
        \end{tabular}
    \end{center}
\end{table*}

    由于段描述符是8字节长，因此在GDT/LDT中的相对地址由段选择符的最高13位数值乘以8得到

    \emph{GDT的第一项总是设置为0，这就确保了空段选择符的逻辑地址会被认为是无效的。因此引起一个处理器异常。}

\subsection{分段单元}

    分段单元(segmentation unit)执行以下步骤：

\begin{itemize}
    \item 首先检查TI字段以决定段描述符保存在哪个描述符表。
    \item 从段选择符的index字段计算段描述符的地址
    \item 把逻辑地址的偏移量与段描述符Base字段的值相加就得到了线性地址
\end{itemize}

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{image/chapter02/逻辑地址的转换.png}
    \caption{逻辑地址的转换}
\end{figure}

    注意：\emph{如果有了不可编程寄存器，只有当段寄存器内容被改变时才需执行前两个操作。}

\section{Linux中的分段}

    实际上分段和分页在某种程度上有点多余，因为都可以划分进程的物理地址空间：\emph{分段可以给每个进程分配不同的线性地址空间， 而分页可以把同一线性地址空间映射到不同的物理空间。}Linux更喜欢分页：

\begin{itemize}
    \item 当所有进程使用相同段寄存器值，内存管理变得更简单，也就是其能共享同样的一组线性地址
    \item RISC架构对分段的支持有限\footnote[1]{\emph{2.6version的Linux只有80x86架构才需要使用分段}}
\end{itemize}

    运行到用户态的所有Linux进程都使用一对相同的段来对指令和数据寻址。也就是用户代码段和用户数据段。相对地，也有内核代码段和内核数据段。

\begin{table*}[!htbp]
    \begin{center}
        \caption{四个主要的Linux段的描述符字段的值}
        \begin{tabular}{c c c c c c c c c}
            \hline
            \emph{段} & \emph{Base} & \emph{G} & \emph{Limit} & \emph{S} & \emph{Type} & \emph{DPL} & \emph{D/B} & \emph{P} \\
            用户代码段 & 0x00000000 & 1 & 0xfffff & 1 & 10 & 3 & 1 & 1 \\
            用户数据段 & 0x00000000 & 1 & 0xfffff & 1 & 2 & 3 & 1 & 1 \\
            内核代码段 & 0x00000000 & 1 & 0xfffff & 1 & 10 & 0 & 1 & 1 \\
            内核数据段 & 0x00000000 & 1 & 0xfffff & 1 & 2 & 0 & 1 & 1 \\
            \hline
        \end{tabular}
    \end{center}
\end{table*}

    相应的段选择符由宏\_\_USER\_CS，\_\_USER\_DS，\_\_KERNEL\_CS和\_\_KERNEL\_DS分别定义。

    \emph{所有的段都从0x00000000开始，也就是说，Linux下逻辑地址与线性地址是一致的，即逻辑地址的偏移量字段与对应的线性地址的值总是一致的。}

    对指令或数据结构的指针进行保存时，内核不需要设置逻辑地址的段选择符，因为CS寄存器含有当前的段选择符。因为已经隐含在CS寄存器中。"在内核态执行"的段只有一种，叫做代码段，由\_\_KERNEL\_CS定义，因此当切换为内核态时，只需要将该宏装入CS即可。

    同样的，对于指向内核数据结构的指针，隐式使用DS，有宏\_\_KERNEL\_DS。

\subsection{Linux GDT}

    多处理器中，每个CPU对应一个GDT。所有的GDT都存放在\emph{`cpu\_gdt\_table`}数组中，而所有的GDT地址和大小(初始化gdtr寄存器时使用)被存放在\emph{`cpu\_gdt\_descr`}数组中。

\begin{lstlisting}[language=C++]
// for i386 GDT_ENTRIES
#define GDT_ENTRIES 32 

// for x86_64 GDT_ENTRIES
#define GDT_ENTRIES 16

// 8 byte segment descriptor
struct desc_struct { 
	u16 limit0;
	u16 base0;
	unsigned base1 : 8, type : 4, s : 1, dpl : 2, p : 1;
	unsigned limit : 4, avl  : 1, l : 1, d   : 1, g : 1, base2 : 8;
} __attribute__((packed)); 

extern struct desc_struct cpu_gdt_table[NR_CPUS][GDT_ENTRIES];

struct Xgt_desc_struct {
	unsigned short size;
	unsigned long address __attribute__((packed));
	unsigned short pad;
} __attribute__ ((packed));

extern struct Xgt_desc_struct idt_descr, cpu_gdt_descr[NR_CPUS];
\end{lstlisting}

    如下是GDT的布局示意图，每个GDT都包含18个描述符和14个空的，未使用的，或保留的。\emph{插入未使用的项目的是为了使经常一起访问呢的描述符能够处于同一个32字节的硬件高速缓存行中}

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{image/chapter02/全局描述符表.png}
    \caption{全局描述符表}
\end{figure}

    每一个GDT中包含的18个段描述符指向下列的段：

\begin{itemize}
    \item 用户态和内核态下的代码段和数据段共四个
    \item 任务状态段(TSS)，每个处理器一个。
    \subitem TSS相应的线性地址空间都是内核数据段相应线性空间的一个小子集。所有的状态任务段都顺序地放在init\_tss数组中。注意：\emph{第n个CPU的TSS描述符的Base字段指向init\_tss数组的第n个元素，G标志清零，Limit字段置为0xeb，Type字段置为9或11且DPL置0}
    \item 1个包括缺省局部描述符的段，通常被所有进程共享的段
    \item 3个局部线程存储(Thread-Local Storage, TLS)段
    \subitem 该机制允许多线程应用程序使用最多3个局部线程的数据段。系统调用set\_thread\_area()和get\_thread\_area()分别创建和撤销一个TLS段
    \item 与高级电源管理(AMP)相关的三个段
    \subitem 由于BIOS代码使用段，所以Linux APM驱动程序调用BIOS函数来获取或设置APM时，可以自定义的代码段和数据段
    \item 与支持即插即用(PnP)功能的BIOS服务程序相关的五个段
    \subitem 当PnP设备驱动程序调用BIOS函数来检查PnP设备使用的资源时，就可以使用自定义的代码段和数据段
    \item 被内核用来处理"双重错误"异常\footnote[1]{\emph{处理异常的程序引发了另一个异常，产生的双重错误}}的特殊TSS段
\end{itemize}

\subsection{Linux LDT}

    大多数用户态Linux不使用局部描述符表，内核定义了一个缺省的LDT供进程共享。缺省的局部描述符放在\emph{`default\_ldt'}数组中，其包含五个项，但内核仅仅有效地使用了其中两个项。

\begin{itemize}
    \item 用于iBCS执行文件的调用门
    \item Solaris/x86可执行文件的调用门
\end{itemize}

    调用门时80x86微处理器提供的一种机制，可以在调用与预定义函数时改变CPU的特权级。

\begin{lstlisting}[language=C++]
// 8 byte segment descriptor
struct desc_struct { 
	u16 limit0;
	u16 base0;
	unsigned base1 : 8, type : 4, s : 1, dpl : 2, p : 1;
	unsigned limit : 4, avl  : 1, l : 1, d   : 1, g : 1, base2 : 8;
} __attribute__((packed)); 

extern struct desc_struct default_ldt[];
\end{lstlisting}

    但是，如同Wine这样的程序，需要创建局部描述符。modify\_ldt()系统调用允许进程创建自己的局部描述符。

    任何被modify\_ldt()创建的自定义局部描述符仍然需要自己的段。

\begin{lstlisting}[language=C++]
/*
* ldt.h
*
* Definitions of structures used with the modify_ldt system call.
*/
#ifndef _LINUX_LDT_H
#define _LINUX_LDT_H

/* Maximum number of LDT entries supported. */
#define LDT_ENTRIES	8192
/* The size of each LDT entry. */
#define LDT_ENTRY_SIZE	8

#ifndef __ASSEMBLY__
struct user_desc {
    unsigned int  entry_number;
    unsigned long base_addr;
    unsigned int  limit;
    unsigned int  seg_32bit:1;
    unsigned int  contents:2;
    unsigned int  read_exec_only:1;
    unsigned int  limit_in_pages:1;
    unsigned int  seg_not_present:1;
    unsigned int  useable:1;
};

#define MODIFY_LDT_CONTENTS_DATA	0
#define MODIFY_LDT_CONTENTS_STACK	1
#define MODIFY_LDT_CONTENTS_CODE	2

#endif /* !__ASSEMBLY__ */
#endif  
\end{lstlisting}

\section{硬件中的分页}

    分页单元(paging unit)把线性地址转换为物理地址。其中的一个关键任务是把所请求的访问类型与线性地址的访问权限比较，若内存访问无效，则产生缺页异常。

    \emph{线性地址被分成以固定长度为单位的组，称为页(page)。}页内部连续的线性地址被映射到连续的物理地址中。内核就能够指定一个页的物理地址和存取权限，而不用指定页所包含的全部线性地址的存取权限。

    一般地，使用属于"页"既指一组线性地址，又指包含在这组地址中的数据。

    分页单元把所有的RAM分成固定长度的页框(page frame)。每个页框包含一个页，也就是说，一个页框的长度和页的长度是一致的。

    把线性地址映射到物理地址的数据结构称为页表(page table)。

    从80386开始，所有的80x86处理器都支持分页，通过设置cr0寄存器的PG标志启用。当PG=0时，线性地址被解释为物理地址

\subsection{常规分页}

    32位的线性地址被分成3个域：

\begin{itemize}
    \item Directory(目录)
    \subitem 最高10位
    \item Table(页表)
    \subitem 中间十位
    \item Offset(偏移量)
    \subitem 最低12位
\end{itemize}

    线性地址的转换分两步，每一步都基于一种转换表。第一种转换表称为页目录表(page directory)，第二种转换表称为页表(page table)

    \emph{使用这种二级模式的目的在于减少每个进程页表所需RAM的数量}。

    正在使用的页目录的物理地址存放在控制寄存器cr3中。

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{image/chapter02/80x86处理器分页.png}
    \caption{80x86处理器分页}
\end{figure}

    线性地址内的Directory字段决定页目录中的目录项，而目录项指向适当的页表。地址的Table字段依次又决定页表中的表项，表项含有页所在页框的物理地址。Offset字段决定页框内的相对位置。

    Directory字段和Table字段都是10位长，因此页目录和页表都可以多达1024项。

    页目录项和页表有同样的结构，每项都包含下面的字段：

\begin{itemize}
    \item Present标志
    \subitem 若被置1，所在页就在主存中；若地址转换所需的页表项或页目录项中Present标志清零，则分页单元就把该线性地址放在控制寄存器cr2中，产生14号缺页异常
    \item 包含页框物理地址最高20位的字段
    \subitem 一个页框4KN大小，因此物理地址是4096的倍数(低12位总是0).
    \item Accessed标志
    \subitem 每当分页单元对相应页框进行寻址时设置。必须被操作系统设置。
    \item Dirty标志
    \subitem 只用于页表项。每当一个页框进行写操作时设置。必须被操作系统设置。
    \item Read/Write标志
    \subitem 含有页或页表的存取权限
    \item User/Supervisor标志
    \subitem 含有访问页或页表所需的特权级
    \item PCD和PWT标志
    \subitem 控制硬件高速缓存处理页或页表的方式
    \item Page Size标志
    \subitem 只用于页目录项。
    \item Global标志
    \subitem 只用于页表项。用来防止页从TLB高速缓存中刷新出去。只有cr4寄存器在页全局启用(Page Global Enable, PGE)标志置位时才有效
\end{itemize}

\subsection{扩展分页}

    80x86引入了扩展分页(extended paging)，允许页框大小为4MB而不是4KB。\emph{扩展分页用于把大段连续的线性地址转换成相应的物理地址(内核可以不用中间页表进行地址转换，从而节省内存并保存TLB项)}

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{image/chapter02/扩展分页.png}
    \caption{扩展分页}
\end{figure}

    通过设置Page Size字段启用扩展分页：

\begin{itemize}
    \item Directory
    \subitem 最高10位
    \item Offset
    \subitem 最高22位
    \item 扩展分页与正常分页页目录项基本相同，除了
    \subitem Page Size必须被设置
    \subitem 20位物理地址字段只有最高10位是有意义的
\end{itemize}

\subsection{硬件保护方案}

    页与页表的特权级只有两个，由User/Supervisor标志控制。页的存储权限只有两种，若Read/Write标志为0，说明是只读的，否则是可读可写的。

\subsection{物理地址扩展(PAE)分页机制}

    \emph{处理器所支持的RAM容量受连接到地址总线上的地址管脚数限制。}

    Intel引入物理地址扩展(Physical Address Extension，PAE)机制，另外一种叫做页大小扩展机制在Pentium中引入。

    通过设置cr4控制寄存器中的物理地址扩展PAE标志激活PAE，为了支持PAE，因此分页机制需要更改：

\begin{itemize}
    \item 64GB的RAM分为$2^{24}$个页框，页表项物理地址字段扩展到24位。
    \item 引入页目录指针表(Page Directory Pointer Table， PDPT)的页表新级别，由四个64位表项组成
    \item cr3控制寄存器包含一个27位的页目录指针表(PDPT)基地址字段。
    \item 把线性地址映射到4KB的页时，32位线性地址按下列方式解释：
    \subitem cr3：指向一个PDPT
    \subitem 位31 - 30：指向PDPT中4个项中的一个
    \subitem 位29 - 21：指向页目录中512个项的一个
    \subitem 位20 - 12：指向页表中512项中的一个
    \subitem 位11 - 0：4KB页中的偏移量
    \item 把线性地址映射到2MB的页时，32位线性地址按下列方式解释：
    \subitem cr3：指向一个PDPT
    \subitem 位31 - 30：指向PDPT中4个项中的一个
    \subitem 位29 - 21：指向页目录中512个项的一个
    \subitem 位20 - 0：2MB页中的偏移量
\end{itemize}

\subsection{硬件高速缓存}

    \emph{为了缩小CPU与RAM之间的速度不匹配，引入了硬件高速缓存内存(hardware cache memory)}。

    \emph{硬件高速缓存基于局部性原理\footnote[1]{\emph{
        1. 时间局部性（Temporal Locality）：指在程序执行过程中，刚刚访问过的数据或指令很可能在不久的将来再次被访问。这是因为程序中的循环、迭代和函数调用等结构会导致对同一数据或指令的重复访问。通过利用时间局部性，计算机系统可以将频繁访问的数据或指令缓存到高速缓存（Cache）中，以提高访问速度。\\
        2. 空间局部性（Spatial Locality）：指在程序执行过程中，与当前访问的数据或指令在空间上相邻的数据或指令很可能在不久的将来被访问。这是因为程序中的数组、结构体和代码块等通常具有连续的存储结构。通过利用空间局部性，计算机系统可以预取和预加载与当前访问的数据或指令相邻的数据或指令，以提高内存访问效率。}
    }(locality principle)},这说明程序的循环结构及相关数组可以组成线性数组，最近最常用的相邻地址在最近的将来可能又会用到。

    为了适应这种机制，80x86引入了行的新单位。\emph{行由几十个连续字节组成，以脉冲突发模式\footnote[2]{\emph{脉冲突发模式是指在通信系统中，用于携载业务和控制信道的信息的一种模式。}}(burst mode)在慢速DRAM和快速SRAM之间传送，实现高速缓存。}

    在极端情况下，高速缓存可以直接映射，此时主存中的一个行总是放在高速缓存中完全相同的位置。另一种情况，高速缓存时全相联的(fully associative)，意味着主存中任意一个行可以存放在高速缓存中的任意位置。大多数高速缓存时N-路组关联的(N-way set associative)，意味着任意一个行能够放在N行中的任意一行

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.6\textwidth]{image/chapter02/高速缓存器.png}
    \caption{高速缓存器}
\end{figure}    

    高速缓存单元插在分页单元和主存之间。包含一个高速缓存内存和高速缓存控制器。高速缓存内存存放内存中真正的行，控制器存放一个表项数组，每个表项对应高速缓存内存中的行。

    每个表项都有一个标签(tag)和描述高速缓存行状态的标志(flag)。

    访问RAM时，CPU从物理地址中提取子集的索引号并把子集种所有行的标签与物理地址的高几位相比较，若相同，则称缓存命中(cache hit)，否则缓存未命中(cache miss)。

    当命中时，高速缓存控制器根据存取类型采取不同的操作。

\begin{itemize}
    \item 读操作
    \subitem \emph{控制器从行种选择数据并送往CPU，不需要访问RAM}
    \item 写操作
    \subitem 控制器有两种方案：通写(write-through)和回写(write-back)
    \subitem \emph{通写中，控制器既写RAM也写高速缓存行}
    \subitem \emph{回写中，控制器只更新高速缓存行，不更改RAM，但回写结束后，RAM必须被更新}
\end{itemize}

    当缓存为命中，高速缓存行被写回RAM中，且有必要的情况下，将正确的行写入高速缓存表项中

    在多处理器中，每一个处理器都有自己的硬件高速缓存，因此需要额外电路来保持缓存内容的同步。

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.6\textwidth]{image/chapter02/双处理器中的高速缓存.png}
    \caption{双处理器中的高速缓存}
\end{figure}

    \emph{高速缓存监听(cache snooping)用于检查CPU是否需要更新，当然这些属于硬件级，内核并不需要关心。}

    处理器上的cr0寄存器的CD标志位用来启用或禁用高速缓存电路，该寄存器的NW标志指明高速缓存是使用通写还是回写。

\subsection{转换后援缓冲器(TLB)}

    80x86中包含了一个TLB(Translation Lookaside Buffer)的高速缓存用于加快线性地址的转换。

    当一个线性地址第一次使用时，通过慢速访问RAM的页表计算出对应的物理地址，同时该物理地址会被存放在TLB表项(entry)以便同一个线性地址可以快速转换。

    注意：\emph{当cr3寄存器更改后，硬件自动使本地TLB中的所有项都无效，因为此时TLB是旧数据。}

\section{Linux中的分页}

    Linux为了能够同时适用于32位和64位系统的普通分页模型，因此采用了三级分页模型，但是从2.6.11版本开始，采用四级分页模型：

\begin{itemize}
    \item 页全局目录(Page Global Directory)
    \item 页上级目录(Page Upper Directory)
    \item 页中间目录(Page Middle Directory)
    \item 页表(Page Table)
\end{itemize}

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{image/chapter02/Linux的分页模式.png}
    \caption{Linux的分页模式}
\end{figure}

    对于没有启用物理地址扩展的32位系统，两级页表已经足够，Linux使页上级目录和页中间目录为0，从而取消该字段。启用了物理地址扩展的32位系统采用了三级页表，页全局目录对应页目录指针表，取消了页上级目录。

    \emph{Linux的进程处理很大程度上依赖于分页，线性地址到物理地址的自动转换使得下面的设计目标变得可行：}

\begin{itemize}
    \item 给每个进程分配一块不同的物理地址空间
    \item 区别页和页框的不同，这使得存放在某个页框中的一个页，可以保存在磁盘上，然后重新装入不同页框内(虚拟机内存机制的基本要素)
\end{itemize}

\subsection{线性地址字段}

    下列宏简化了页表处理(全在include/asm-x86\_64/pgtable.h中)

\begin{itemize}
    \item PAGE\_SHIFT
    \subitem 指定Offset字段的位数。当使用80x86处理器时，默认的指为12。
    \subitem 该宏由PAGE\_SIZE使用以返回页大小，最后由PAGE\_MASK产生的指0xfffff000，来屏蔽Offset字段
    \item PMD\_SHIFT
    \subitem 指定线性地址的Offset字段和Table字段的总位数。
    \subitem PMD\_SIZE用于计算由页中间目录的一个单独表项所映射的区域大小，PMD\_MASK用于屏蔽Offset和Table字段的所有位
    \subitem 当PAE被禁用时，PMD\_SHIFT的指为22(Offset的12位 + Table的10位)；PMD\_SIZE的值为$2^{22}$，PMD\_MASK的值为0fffc00000
    \subitem 当PAE被激活时，PMD\_SHIFT的指为21(Offset的12位 + Table的9位)；PMD\_SIZE的值为$2^{21}$，PMD\_MASK的值为0fffe00000
    \item PUD\_SHIFT
    \subitem 确定页上级目录项能映射的区域大小的对数
    \subitem PUD\_SIZE用于计算页全局目录中的一个单独表项所能映射的区域，PUD\_MASK用于频闭Offset字段、Table、Middle Air字段和Upper Air字段
    \item PGDIR\_SHIFT
    \subitem 去欸的那个页全局目录能映射的大小的对数
    \subitem PGDIR\_SIZE用于计算页全局目录中一个单独的表项所能映射的区域，PGDIR\_MASK用于用于频闭Offset字段、Table、Middle Air字段和Upper Air字段
\end{itemize}

\subsection{页表处理}

    pte\_t、pmd\_t、pud\_t和pgd\_t分别描述页表项、页中间目录项、页上级目录项和页全局目录项的格式。\emph{当PAE被激活时，都是64位的数据类型，否则为32位数据类型}

    pgprot\_t是另一个64位(32位)的数据类型，表示与一个单独表项相关的保护标志

    五种类型转换红(\_\_pte, \_\_pmd, \_\_pud, \_\_pgd和\_\_pgrot)把一个无符号整数转换为所需的类型，另外五种类型转换宏(pte\_val, pmd\_val, pud\_val, pgd\_val和pgrot\_val)执行相反的转换。

\begin{lstlisting}[language=C++]
// 如果对应表项为0，则返回值为1
#define pte_none(x)	(!pte_val(x))
#define pmd_none(x)	(!pmd_val(x))
#define pud_none(x)	(!pud_val(x))
#define pgd_none(x)	(!pgd_val(x))

// 原子的写入指定值
#define set_pte(pteptr, pteval) (*(pteptr) = pteval)
#define set_pte_atomic(pteptr, pteval) set_pte(pteptr,pteval)

// 若a和b指向同一页且指定相同访问优先级
#define pte_same(a, b)		((a).pte == (b).pte)
#define pte_same(a, b)		((a).pte_low == (b).pte_low)

// 通过输入参数传递来检查页中间目录项，若指向一个不能使用的页表，宏值为1
#define	pmd_bad(x)	\
    ((pmd_val(x) & (~PTE_MASK & ~_PAGE_USER)) != _KERNPG_TABLE )
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={读页标志的函数}]
static inline int pte_user(pte_t pte)   // 读User/Supervisor标志
    { return pte_val(pte) & _PAGE_USER; }
extern inline int pte_read(pte_t pte)   // 读User/Supervisor标志
    { return pte_val(pte) & _PAGE_USER; }
extern inline int pte_exec(pte_t pte)   // 读User/Supervisor标志
    { return pte_val(pte) & _PAGE_USER; }
extern inline int pte_dirty(pte_t pte)  // 读Dirty标志
    { return pte_val(pte) & _PAGE_DIRTY; }
extern inline int pte_young(pte_t pte)  // 读Accessed标志
    { return pte_val(pte) & _PAGE_ACCESSED; }
extern inline int pte_write(pte_t pte)	// 读Read/Write标志
    { return pte_val(pte) & _PAGE_RW; }
static inline int pte_file(pte_t pte)   // 读Dirty标志
    { return pte_val(pte) & _PAGE_FILE; }
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={设置页标志的函数}]
extern inline pte_t pte_mkread(pte_t pte)       // 设置U/S标志
extern inline pte_t pte_mkexec(pte_t pte)       // 设置U/S标志
extern inline pte_t pte_rdprotect(pte_t pte)    // 清除U/S标志
extern inline pte_t pte_exprotect(pte_t pte)	// 清除U/S标志

extern inline pte_t pte_mkold(pte_t pte)        // 清除Accessed标志
extern inline pte_t pte_mkyoung(pte_t pte)      // 设置Accessed标志

extern inline pte_t pte_wrprotect(pte_t pte)    // 清除R/W标志
extern inline pte_t pte_mkwrite(pte_t pte)      // 设置R/W标志

extern inline pte_t pte_mkdirty(pte_t pte)      // 设置Dirty标志
extern inline pte_t pte_mkclean(pte_t pte)      // 清除Dirty标志

// 与pte_mkclean类似，但作用于指向页表项的指针，并返回旧值
static inline int ptep_test_and_clear_dirty(pte_t *ptep)
// 与pte_mkold类似，但作用于指向页表项的指针，并返回旧值
static inline int ptep_test_and_clear_young(pte_t *ptep)
// 与pte_wrprotect类似，但作用于指向页表项的指针
static inline void ptep_set_wrprotect(pte_t *ptep)
// 与pte_mkdirty类似，但作用于指向页表项的指针
static inline void ptep_mkdirty(pte_t *ptep)

// 将页表项p访问权限设置为指定值v
extern inline pte_t pte_modify(pte_t pte, pgprot_t newprot)

// 设置页表项中的Page Size和Present
#define mk_pte_huge(entry) \
    (pte_val(entry) |= _PAGE_PRESENT | _PAGE_PSE)
\end{lstlisting}
    
\begin{lstlisting}[language=C++, caption={对页表项操作的宏}]
暂时略过
\end{lstlisting}

\subsection{物理内存布局}

    \emph{在初始化阶段，内核必须建立在一个物理地址映射来指定哪些物理地址范围对内核可用}。

    内核将下列页框记为保留：

\begin{itemize}
    \item 在不可用的物理地址范围内的页框
    \item 含有内核代码和已初始化的数据结构的页框
\end{itemize}

    \emph{保留的页框中的页绝不能被动态分配或交换到磁盘上。}

    Linux通常从0x00100000开始的地方启动，因为在之前的RAM需要留给：

\begin{itemize}
    \item 页框0由BIOS使用，存放加电自检(Power-On Self-Test，POST)期间检查到的系统硬件配置
    \item 物理地址从0x000a0000到0x000fffff的范围通常留给BIOS例程，并且映射ISA图形卡的内部内存。
    \item 第一个MB内的其他页框可能由特定计算机模型保留
\end{itemize}

    在启动过程早期，内核询问BIOS并了解物理内存大小，随后内核执行machie\_specific\_-memory\_setup()函数，建立物理地址映射

\begin{table*}[!htbp]
    \begin{center}
        \caption{BIOS提供的物理地址映射举例}
        \begin{tabular}{c c c}
            \hline
            开始 & 结束 & 类型 \\
            0x00000000 & 0x0009ffff & Usable \\
            0x000f0000 & 0x000fffff & Reserved \\
            0x00100000 & 0x07feffff & Usable \\
            0x07ff0000 & 0x07ff2ffff & ACPI data \\
            0x07ff3000 & 0x07fffffff & ACPI NVS \\
            0xffff0000 & 0xfffffffff & Reserved \\
        \end{tabular}
    \end{center}
\end{table*}

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.6\textwidth]{image/chapter02/内核物理内存布局的变量.png}
    \caption{描述内核物理内存布局的变量}
\end{figure}

    为了避免把内核装入一组不连续的页框内，Linux更愿意跳过RAM中的第一个MB

\subsection{进程页表}

    进程的线性地址空间被分为两部分：

\begin{itemize}
    \item 从0x0到0xbfffffff的线性地址，无论进程运行在用户态还是内核态都可以寻址
    \item 从0xc00000000到0xffffffff的线性地址，只有内核态的进程能够寻址
\end{itemize}

\subsection{内核页表}

    内核维持着一组自己使用的页表，驻留在主内核页全局目录中。

    内核初始化自身的页表分为两个阶段：

\begin{itemize}
    \item 第一阶段创建一个有限的地址空间，包括内核的代码段和数据段、初试页表和用于存放动态数据结构的共128KB大小的空间
    \item 第二阶段利用剩余的RAM并适当的建立分页表
\end{itemize}

\subsubsection{临时内核页表}

    略

\subsection{固定映射的线性地址}

    固定映射的线性地址(fix-mapped linear address)基本上是一种类似于0xffffc000这样的常量线性地址，其对应的物理地址不必定于线性地址减去0xc000000。

    每个固定映射的线性地址由enum fixed\_addresses数据结构中的整形索引来表示：

\begin{lstlisting}[language=C++]
enum fixed_addresses {
    VSYSCALL_LAST_PAGE,
    VSYSCALL_FIRST_PAGE = \
        VSYSCALL_LAST_PAGE + \
        ((VSYSCALL_END-VSYSCALL_START) >> PAGE_SHIFT) - 1,
    VSYSCALL_HPET,
    FIX_HPET_BASE,
#ifdef CONFIG_X86_LOCAL_APIC
    FIX_APIC_BASE,	/* local (CPU) APIC) -- required for SMP or not */
#endif
#ifdef CONFIG_X86_IO_APIC
    FIX_IO_APIC_BASE_0,
    FIX_IO_APIC_BASE_END = FIX_IO_APIC_BASE_0 + MAX_IO_APICS-1,
#endif
    __end_of_fixed_addresses
};


#define __fix_to_virt(x)	(FIXADDR_TOP - ((x) << PAGE_SHIFT))
extern void __this_fixmap_does_not_exist(void);

/*
 * 'index to address' translation. If anyone tries to use the idx
 * directly without translation, we catch the bug with a NULL-deference
 * kernel oops. Illegal ranges of incoming indices are caught too.
 */
extern inline unsigned long fix_to_virt(const unsigned int idx)
{
	/*
	 * this branch gets completely eliminated after inlining,
	 * except when someone tries to use fixaddr indices in an
	 * illegal way. (such as mixing up address types or using
	 * out-of-range indices).
	 *
	 * If it doesn't get removed, the linker will complain
	 * loudly with a reasonably clear error message..
	 */
	if (idx >= __end_of_fixed_addresses)
		__this_fixmap_does_not_exist();

    return __fix_to_virt(idx);
}
\end{lstlisting}

