# 网络基础2

---  

## UDP的特点

| 0 | 15 | 16 | 31 |
| --- | --- | --- | --- | 
| 16位 | 源端口号 | 16位 | 目的端口号 | 
| 16位 | UDP长度 | 16位 | UDP检验和 | 
| | 数据 | (如果有) | | 

- UDP如何保证报头和有效载荷分离
	- UDP的报头是定长报头，也就是8字节报头，只要识别到前8字节就可以识别到UDP的报头

- UDP如何决定自己的有效载荷交付给上层的哪一个协议
	- 通过目的端口号来识别目的进程

> 什么叫做报头
>> udp协议属于内核协议栈(C语言)

```C
struct udp_header{
	unsigned int src_port: 16;
	unsigned int dst_port: 16;
	unsigned int udp_len: 16;
	unsigned int udp_chk: 16;
};

struct udp_header* uh = malloc(sizeof(udp_header));
uh->src_port = 9099;
uh->dst_port = 8080;
uh->udp_len = 10;
uh->udp_chk = XXXX;
```

> 传输层如何通过端口，找到对应的服务进程(理论)
>> 端口号在底层是通过hash表一一对应的，因此底层上来的端口号，直接通过hash映射来找到对应的服务进程


- 无链接：知道对端的IP和端口号直接进行传输，不需要连接
- 不可靠：没有确认机制，没有重传机制
- 面向数据报：不能灵活的控制读写数据的次数和数量
	- 应用层交给UDP多长的报文，UDP照原样发送，不会拆分也不会合并

- UDP的缓冲区
	- UDP没有真正意义上的发送缓冲区，调用sendto会直接交给内核，由内核将数据传给网络层协议进行后续的传输动作
	- UDP具有接受缓冲区，但是这个缓冲区不能保证收到的UDP报的顺序和发送UDP报的顺序一致。如果缓冲区满了，再达到的UDP数据就会丢弃
	- UDP的socket既能读也能写，因此叫做全双工


## TCP的特点

| 0 | 15 | 16 | 31 |
| --- | --- | --- | --- | 
| 16位 | 源端口号 | 16位 | 目的端口号 | 
| | 32位 | 序号 | | 
| 4位首部长度(向后保留6位) | URG、ACK、PSH、RST、SYN、FIN | 16位 | 窗口大小 |
| 16位 | 校验和 | 16位 | 紧急指针 |
| | 选 | 项 | | 
| | 数 | 据 | | 

![[Pasted image 20220812181601.png]]


- TCP可靠意味着要做更多的工作，引起不可靠的情况越多，保证可靠的成本越高，也就是时间+空间复杂度越高

- 4位首部长度
	- 表示该TCP头部有多少个32位bit,因此TCP头部最大长度就是15\*4 = 60。**(它的基本单位不能是bit)**

- TCP报头和有效载荷如何分离？
	- 通过四位首部长度，来确定报头的具体长度，从而获取到报头和有效载荷

- TCP如何决定，将自己的有效载荷交付给上层的哪一个协议？
	- TCP报文中有目的端口号，通过目的端口号来确定在哪一层协议

> 什么是窗口大小？
>> 自身的接收缓冲区中剩余空间大小，**支持流量控制**
>
> 什么是校验和
>> 用于检验TCP传输过程中是否有丢包现象
>
> 紧急指针
>> **就是紧急数据在报文中的偏移量，用于指出紧急数据的具体位置**

### TCP的可靠性机制

> 什么是可靠？
>> 一般而言，我们认为，只有我们发送的消息**收到了回应**，才算我们发送的消息是可靠的被对方收到

> 当client发送一批数据的时候，server端是否有能力识别中间有一部分丢失了
>> 有能力来识别！是用报文中的32位序号来确保的

- **实际上，响应也是一个完整的TCP报文！**

- 确认序号，是对应的32位序号+1,**代表告知对方，你给我发送的n个字节之前的所有字节我已经全部收到，请下一次从n开始发送**

### 六个标志位

> TCP报文是拥有种类的。区分不同报文，实现不同的逻辑处理

#### SYN

> 连接请求报文，用于启动和建立连接

- 在链接建立阶段SYN才会被设置

#### ACK

> 确认请求报文，用于帮助向对方确认它已收到 SYN

- 一般而言，ACK字段是会被经常设置的

#### 三次握手

1. 客户端向服务器发起SYN链接请求
2. 服务器收到SYN请求后，返回SYN和ACK确认请求，允许客户端的链接
3. 客户端收到服务器信息，再次发送ACK,确认客户端可以正常允许

- 三次握手属于通信细节，**上层用户不需要关心**，双方的操作系统自动完成
- connect() --> 发起三次握手，accept() --> 获取已经建立好的链接，已经完成三次握手的链接
- **三次握手建立连接是有可能出错的，出错在第三次**

#### FIN

> finish，结束请求报文，用于断开链接

#### 四次挥手

1. 服务器向客户端发起FIN断开链接请求
2. 客户端收到FIN请求后，返回ACK确认请求，允许服务器断开链接
3. 客户端向服务器发起FIN断开连接请求
4. 服务器收到FIN请求后，返回ACK确认请求，允许服务器断开连接

#### URG

> URG 标志用于通知接收站，段内的某些数据是紧急的，应该优先处理。 如果设置了 URG 标志，则接收站评估紧急指针，即 TCP 标头中的 16 位字段。 该指针指示段中从第一个字节开始计数的数据有多少是紧急的。

- 如果一个数据需要提前被读取
	- URG + 16位紧急指针
- **TCP只能允许一个字节的紧急指针字段**

- recv中最后一个参数，flag中有一个为MSG_OOB

> OOB：out of band 带外数据，意味着就是紧急指针

#### PSH

> PSH：push，推送。告诉对端，**尽快的将数据交付给上层**

#### RST

> RST：reset，重建。当双方链接有问题时，使用RST，重新建立链接

### 链接

#### 理解链接

> server : client = 1 : n，存在很多的客户端，连接server。

- 面向链接是TCP可靠性的一种
- OS需要管理链接
	- 先描述，再组织
	- 需要花费成本(时间 + 空间)

#### 理解断开

> 释放曾经建立好的链接结构体字段

### 确认应答机制

![[Pasted image 20220817192413.png]]

### 超时重传机制

1. 传输丢包
2. 应答丢包

![[Pasted image 20220817195328.png]]

 ### 链接管理机制

#### 为什么是三次握手？

- TCP是全双工协议，链接建立的核心要务：**首先要验证双方的通信信道是联通的。而三次握手是验证双方通信信道的最小次数**

- 链接建立异常的情况下，**一定已经建立的链接是在client端上**，而奇数次建立，异常是在client端上的，这样能够有效的节约资源(**谁最后发送ACK，谁就先维护链接**)

#### 四次挥手的状态

> 如果只有client close，会有什么现象？
>> server端会出现大量CLOSE_WAIT状态的链接
>> 会造成fd(file direction)泄露以及造成链接资源浪费

##### TIME_WAIT

> 如果在最后一次FIN时，**为了防止ACK响应被丢失之后，重传的响应报文能够被接受**

- 通过等待，较大概率保证最后一个ACK被对方收到
- 保证双方通信信道上面的正常数据在网络中，尽可能的消散

## 窗口

### 窗口大小

> 对方的接受能力，衡量的是接收缓冲区剩余空间的大小

### 滑动窗口

> 在自己的发送缓冲区中，限定的一块区域可以直接发送(**暂时不用ACK**)

- 滑动窗口大小 = min(对方的接受能力，自己的拥塞窗口大小)

### 拥塞窗口

> 可能引起拥塞状态的一种阈值

## 流量控制

> 接收端处理数据的速度是有限的。如果发送端发的太快，导致接收端的缓冲区被打满，这个时候如果发送端继续发送就会导致丢包，进而引起丢包重传等一系列连锁反应。
> **因此，TCP支持根据接收端的处理能力，来决定发送端的发送速度，这个机制叫做流量控制**

- 接收端将自己可以接受的缓冲区大小放入TCP首部的**窗口大小**字段，通过ACK端通知发送端
- 窗口大小字段越大，说明网络的吞吐量越高
- 接收端一旦发现自己的接收缓冲区快满了，就会将窗口大小设置成一个更小的值通知给发送端
- 发送端接收到这个窗口之后，就会减慢自己的发送速度
- 如果接收端缓冲区满了，就会将窗口置为0，**这时发送方不再发送数据，但是需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端**

## 拥塞控制

> 当网络中发送数据的时候，出现了大量的丢包，此时不是正常的现象。**网络出现了拥塞问题**

### 做法

- 重传

> 这是不可取的，如果重传会导致网络的负载更大，加重拥塞状态

- 尽量不发，或者少发数据等待网络恢复

### 慢启动机制

> 先发送少量数据，摸清当前的网络状态，再决定按多大数据量传送数据

- 拥塞窗口的增长速度是**指数级别**的
	- 为了不增长那么快，因此不能使用拥塞库窗口单纯的加倍
	- 而**慢启动机制还有一个阈值**
	- 当拥塞窗口超过这个阈值时，就按照线性方式增长

![[Pasted image 20220819200308.png]]

## 延迟应答

 - 当接受数据的主机立刻返回ACK应答，这时候返回的窗口可能比较小
 - 那么如果我们在确保不会超时的情况下，适当的延迟应答，**那么会使得数据更大概率的被上层应用接受，从而使得接受缓冲区剩余空间变大，因此能够提高传输效率**

## 捎带应答

![[Pasted image 20220819205414.png]]

- 经常出现在ACK应答上

## 粘包问题

> 所谓粘包问题主要还是因为**接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的**。 
> 此外，发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一个TCP段。 若连续几次需要send的数据都很少，通常TCP会根据优化算法把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据。 
> **TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。** 收发两端（客户端和服务器端）都要有一一成对的socket
> 因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。

![[Pasted image 20220819213148.png]]

## Listen的第二个参数

> Linux内核协议为一个TCP链接管理使用两个队列
>> 半链接队列(用于保存处于SYN_SENT和SYN_RECV状态的请求)
>> 全链接队列(accept队列，用于保存处于established状态，**但是应用层没有调用accept取走的请求**)

- **全链接队列的长度会受到listen的第二个参数影响** 

- 为什么要有链接队列？

> 当内部有空闲时，立马从链接队列选取一个链接进行处理(**保证服务器几乎100%的工作效率**) 

- 为什么链接队列不能太长？

> 维护链接是要有成本的，与其维护链接长度，造成client等待过久，并且大量的占用暂时用不到的资源，不如把这些资源部分节省出来给server调用

## SYN洪水攻击

> 只给server端发送SYN，而不对SYN+ACK进行回应

- 如果大量的这样的链接在半链接队列中，则会导致半链接队列拥塞

 