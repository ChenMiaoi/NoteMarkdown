# 网络基础2

---  

## UDP的特点

| 0 | 15 | 16 | 31 |
| --- | --- | --- | --- | 
| 16位 | 源端口号 | 16位 | 目的端口号 | 
| 16位 | UDP长度 | 16位 | UDP检验和 | 
| | 数据 | (如果有) | | 

- UDP如何保证报头和有效载荷分离
	- UDP的报头是定长报头，也就是8字节报头，只要识别到前8字节就可以识别到UDP的报头

- UDP如何决定自己的有效载荷交付给上层的哪一个协议
	- 通过目的端口号来识别目的进程

> 什么叫做报头
>> udp协议属于内核协议栈(C语言)

```C
struct udp_header{
	unsigned int src_port: 16;
	unsigned int dst_port: 16;
	unsigned int udp_len: 16;
	unsigned int udp_chk: 16;
};

struct udp_header* uh = malloc(sizeof(udp_header));
uh->src_port = 9099;
uh->dst_port = 8080;
uh->udp_len = 10;
uh->udp_chk = XXXX;
```

> 传输层如何通过端口，找到对应的服务进程(理论)
>> 端口号在底层是通过hash表一一对应的，因此底层上来的端口号，直接通过hash映射来找到对应的服务进程


- 无链接：知道对端的IP和端口号直接进行传输，不需要连接
- 不可靠：没有确认机制，没有重传机制
- 面向数据报：不能灵活的控制读写数据的次数和数量
	- 应用层交给UDP多长的报文，UDP照原样发送，不会拆分也不会合并

- UDP的缓冲区
	- UDP没有真正意义上的发送缓冲区，调用sendto会直接交给内核，由内核将数据传给网络层协议进行后续的传输动作
	- UDP具有接受缓冲区，但是这个缓冲区不能保证收到的UDP报的顺序和发送UDP报的顺序一致。如果缓冲区满了，再达到的UDP数据就会丢弃
	- UDP的socket既能读也能写，因此叫做全双工


## TCP的特点

| 0 | 15 | 16 | 31 |
| --- | --- | --- | --- | 
| 16位 | 源端口号 | 16位 | 目的端口号 | 
| | 32位 | 序号 | | 
| 4位首部长度(向后保留6位) | URG、ACK、PSH、RST、SYN、FIN | 16位 | 窗口大小 |
| 16位 | 校验和 | 16位 | 紧急指针 |
| | 选 | 项 | | 
| | 数 | 据 | | 

![[Pasted image 20220812181601.png]]


- TCP可靠意味着要做更多的工作，引起不可靠的情况越多，保证可靠的成本越高，也就是时间+空间复杂度越高

- 4位首部长度
	- 表示该TCP头部有多少个32位bit,因此TCP头部最大长度就是15\*4 = 60。**(它的基本单位不能是bit)**

- TCP报头和有效载荷如何分离？
	- 通过四位首部长度，来确定报头的具体长度，从而获取到报头和有效载荷

- TCP如何决定，将自己的有效载荷交付给上层的哪一个协议？
	- TCP报文中有目的端口号，通过目的端口号来确定在哪一层协议

> 什么是窗口大小？
>> 自身的接收缓冲区中剩余空间大小，**支持流量控制**
>
> 什么是校验和
>> 用于检验TCP传输过程中是否有丢包现象
>
> 紧急指针
>> **就是紧急数据在报文中的偏移量，用于指出紧急数据的具体位置**

### TCP的可靠性机制

> 什么是可靠？
>> 一般而言，我们认为，只有我们发送的消息**收到了回应**，才算我们发送的消息是可靠的被对方收到

> 当client发送一批数据的时候，server端是否有能力识别中间有一部分丢失了
>> 有能力来识别！是用报文中的32位序号来确保的

- **实际上，响应也是一个完整的TCP报文！**

- 确认序号，是对应的32位序号+1,**代表告知对方，你给我发送的n个字节之前的所有字节我已经全部收到，请下一次从n开始发送**

### 六个标志位

> TCP报文是拥有种类的。区分不同报文，实现不同的逻辑处理

#### SYN

> 连接请求报文，用于启动和建立连接

- 在链接建立阶段SYN才会被设置

#### ACK

> 确认请求报文，用于帮助向对方确认它已收到 SYN

- 一般而言，ACK字段是会被经常设置的

#### 三次握手

1. 客户端向服务器发起SYN链接请求
2. 服务器收到SYN请求后，返回SYN和ACK确认请求，允许客户端的链接
3. 客户端收到服务器信息，再次发送ACK,确认客户端可以正常允许

- 三次握手属于通信细节，**上层用户不需要关心**，双方的操作系统自动完成
- connect() --> 发起三次握手，accept() --> 获取已经建立好的链接，已经完成三次握手的链接

#### FIN

> finish，结束请求报文，用于断开链接

#### 四次挥手

1. 服务器向客户端发起FIN断开链接请求
2. 客户端收到FIN请求后，返回ACK确认请求，允许服务器断开链接
3. 客户端向服务器发起FIN断开连接请求
4. 服务器收到FIN请求后，返回ACK确认请求，允许服务器断开连接

#### URG

> URG 标志用于通知接收站，段内的某些数据是紧急的，应该优先处理。 如果设置了 URG 标志，则接收站评估紧急指针，即 TCP 标头中的 16 位字段。 该指针指示段中从第一个字节开始计数的数据有多少是紧急的。

- 如果一个数据需要提前被读取
	- URG + 16位紧急指针
- **TCP只能允许一个字节的紧急指针字段**



### 链接

#### 理解链接

> server : client = 1 : n，存在很多的客户端，连接server。

- 面向链接是TCP可靠性的一种
- OS需要管理链接
	- 先描述，再组织
	- 需要花费成本(时间 + 空间)

#### 理解断开

> 释放曾经建立好的链接结构体字段

