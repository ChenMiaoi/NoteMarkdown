# 网络基础2

---  

## UDP的特点

| 0 | 15 | 16 | 31 |
| --- | --- | --- | --- | 
| 16位 | 源端口号 | 16位 | 目的端口号 | 
| 16位 | UDP长度 | 16位 | UDP检验和 | 
| | 数据 | (如果有) | | 

- UDP如何保证报头和有效载荷分离
	- UDP的报头是定长报头，也就是8字节报头，只要识别到前8字节就可以识别到UDP的报头

- UDP如何决定自己的有效载荷交付给上层的哪一个协议
	- 通过目的端口号来识别目的进程

> 什么叫做报头
>> udp协议属于内核协议栈(C语言)

```C
struct udp_header{
	unsigned int src_port: 16;
	unsigned int dst_port: 16;
	unsigned int udp_len: 16;
	unsigned int udp_chk: 16;
};

struct udp_header* uh = malloc(sizeof(udp_header));
uh->src_port = 9099;
uh->dst_port = 8080;
uh->udp_len = 10;
uh->udp_chk = XXXX;
```

> 传输层如何通过端口，找到对应的服务进程(理论)
>> 端口号在底层是通过hash表一一对应的，因此底层上来的端口号，直接通过hash映射来找到对应的服务进程


- 无链接：知道对端的IP和端口号直接进行传输，不需要连接
- 不可靠：没有确认机制，没有重传机制
- 面向数据报：不能灵活的控制读写数据的次数和数量
	- 应用层交给UDP多长的报文，UDP照原样发送，不会拆分也不会合并

- UDP的缓冲区
	- UDP没有真正意义上的发送缓冲区，调用sendto会直接交给内核，由内核将数据传给网络层协议进行后续的传输动作
	- UDP具有接受缓冲区，但是这个缓冲区不能保证收到的UDP报的顺序和发送UDP报的顺序一致。如果缓冲区满了，再达到的UDP数据就会丢弃
	- UDP的socket既能读也能写，因此叫做全双工


## TCP的特点

| 0 | 15 | 16 | 31 |
| --- | --- | --- | --- | 
| 16位 | 源端口号 | 16位 | 目的端口号 | 
| | 32位 | 序号 | | 
| 4位首部长度(向后保留6位) | URG、ACK、PSH、RST、SYN、FIN | 16位 | 窗口大小 |
| 16位 | 校验和 | 16位 | 紧急指针 |
| | 选 | 项 | | 
| | 数 | 据 | | 


- TCP可靠意味着要做更多的工作，引起不可靠的情况越多，保证可靠的成本越高，也就是时间+空间复杂度越高

